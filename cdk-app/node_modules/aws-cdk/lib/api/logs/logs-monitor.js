"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudWatchLogEventMonitor = void 0;
const util = require("util");
const chalk = require("chalk");
const logging_1 = require("../../logging");
const arrays_1 = require("../../util/arrays");
/**
 * After reading events from all CloudWatch log groups
 * how long should we wait to read more events.
 *
 * If there is some error with reading events (i.e. Throttle)
 * then this is also how long we wait until we try again
 */
const SLEEP = 2000;
class CloudWatchLogEventMonitor {
    constructor(startTime) {
        var _a;
        /**
         * Map of environment (account:region) to LogGroupsAccessSettings
         */
        this.envsLogGroupsAccessSettings = new Map();
        this.active = false;
        this.startTime = (_a = startTime === null || startTime === void 0 ? void 0 : startTime.getTime()) !== null && _a !== void 0 ? _a : Date.now();
    }
    /**
     * resume reading/printing events
     */
    activate() {
        this.active = true;
        this.scheduleNextTick(0);
    }
    /**
     * deactivates the monitor so no new events are read
     * use case for this is when we are in the middle of performing a deployment
     * and don't want to interweave all the logs together with the CFN
     * deployment logs
     *
     * Also resets the start time to be when the new deployment was triggered
     * and clears the list of tracked log groups
     */
    deactivate() {
        this.active = false;
        this.startTime = Date.now();
        this.envsLogGroupsAccessSettings.clear();
    }
    /**
     * Adds CloudWatch log groups to read log events from.
     * Since we could be watching multiple stacks that deploy to
     * multiple environments (account+region), we need to store a list of log groups
     * per env along with the SDK object that has access to read from
     * that environment.
     */
    addLogGroups(env, sdk, logGroupNames) {
        var _a;
        const awsEnv = `${env.account}:${env.region}`;
        const logGroupsStartTimes = logGroupNames.reduce((acc, groupName) => {
            acc[groupName] = this.startTime;
            return acc;
        }, {});
        this.envsLogGroupsAccessSettings.set(awsEnv, {
            sdk,
            logGroupsStartTimes: {
                ...(_a = this.envsLogGroupsAccessSettings.get(awsEnv)) === null || _a === void 0 ? void 0 : _a.logGroupsStartTimes,
                ...logGroupsStartTimes,
            },
        });
    }
    scheduleNextTick(sleep) {
        setTimeout(() => void (this.tick()), sleep);
    }
    async tick() {
        if (!this.active) {
            return;
        }
        try {
            const events = arrays_1.flatten(await this.readNewEvents());
            events.forEach(event => {
                this.print(event);
            });
        }
        catch (e) {
            logging_1.error('Error occurred while monitoring logs: %s', e);
        }
        this.scheduleNextTick(SLEEP);
    }
    /**
     * Reads all new log events from a set of CloudWatch Log Groups
     * in parallel
     */
    async readNewEvents() {
        const promises = [];
        for (const settings of this.envsLogGroupsAccessSettings.values()) {
            for (const group of Object.keys(settings.logGroupsStartTimes)) {
                promises.push(this.readEventsFromLogGroup(settings, group));
            }
        }
        return Promise.all(promises);
    }
    /**
     * Print out a cloudwatch event
     */
    print(event) {
        logging_1.print(util.format('[%s] %s %s', chalk.blue(event.logGroupName), chalk.yellow(event.timestamp.toLocaleTimeString()), event.message.trim()));
    }
    /**
     * Reads all new log events from a CloudWatch Log Group
     * starting at either the time the hotswap was triggered or
     * when the last event was read on the previous tick
     */
    async readEventsFromLogGroup(logGroupsAccessSettings, logGroupName) {
        var _a, _b;
        const events = [];
        // log events from some service are ingested faster than others
        // so we need to track the start/end time for each log group individually
        // to make sure that we process all events from each log group
        const startTime = (_a = logGroupsAccessSettings.logGroupsStartTimes[logGroupName]) !== null && _a !== void 0 ? _a : this.startTime;
        let endTime = startTime;
        try {
            const response = await logGroupsAccessSettings.sdk.cloudWatchLogs().filterLogEvents({
                logGroupName: logGroupName,
                limit: 100,
                startTime: startTime,
            }).promise();
            const filteredEvents = (_b = response.events) !== null && _b !== void 0 ? _b : [];
            for (const event of filteredEvents) {
                if (event.message) {
                    events.push({
                        message: event.message,
                        logGroupName,
                        timestamp: event.timestamp ? new Date(event.timestamp) : new Date(),
                    });
                    if (event.timestamp && endTime < event.timestamp) {
                        endTime = event.timestamp;
                    }
                }
            }
            // if we have > 100 events let the user know some
            // messages have been supressed. We are essentially
            // showing them a sampling (10000 events printed out is not very useful)
            if (filteredEvents.length > 0 && response.nextToken) {
                events.push({
                    message: '>>> `watch` shows only the first 100 log messages - the rest have been truncated...',
                    logGroupName,
                    timestamp: new Date(endTime),
                });
            }
        }
        catch (e) {
            // with Lambda functions the CloudWatch is not created
            // until something is logged, so just keep polling until
            // there is somthing to find
            if (e.code === 'ResourceNotFoundException') {
                return [];
            }
            throw e;
        }
        logGroupsAccessSettings.logGroupsStartTimes[logGroupName] = endTime + 1;
        return events;
    }
}
exports.CloudWatchLogEventMonitor = CloudWatchLogEventMonitor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9ncy1tb25pdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibG9ncy1tb25pdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDZCQUE2QjtBQUU3QiwrQkFBK0I7QUFDL0IsMkNBQTZDO0FBQzdDLDhDQUE0QztBQUc1Qzs7Ozs7O0dBTUc7QUFDSCxNQUFNLEtBQUssR0FBRyxJQUFLLENBQUM7QUEwQ3BCLE1BQWEseUJBQXlCO0lBYXBDLFlBQVksU0FBZ0I7O1FBUDVCOztXQUVHO1FBQ2MsZ0NBQTJCLEdBQUcsSUFBSSxHQUFHLEVBQW1DLENBQUM7UUFFbEYsV0FBTSxHQUFHLEtBQUssQ0FBQztRQUdyQixJQUFJLENBQUMsU0FBUyxTQUFHLFNBQVMsYUFBVCxTQUFTLHVCQUFULFNBQVMsQ0FBRSxPQUFPLHFDQUFNLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFRO1FBQ2IsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7UUFDbkIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLFVBQVU7UUFDZixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUM1QixJQUFJLENBQUMsMkJBQTJCLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDM0MsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLFlBQVksQ0FBQyxHQUFzQixFQUFFLEdBQVMsRUFBRSxhQUF1Qjs7UUFDNUUsTUFBTSxNQUFNLEdBQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUM5QyxNQUFNLG1CQUFtQixHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLEVB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QUFNLENBQUM7SUFDaEIsQ0FBQztDQUNGO0FBdEtELDhEQXNLQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV0aWwgZnJvbSAndXRpbCc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0IHsgcHJpbnQsIGVycm9yIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBmbGF0dGVuIH0gZnJvbSAnLi4vLi4vdXRpbC9hcnJheXMnO1xuaW1wb3J0IHsgSVNESyB9IGZyb20gJy4uL2F3cy1hdXRoJztcblxuLyoqXG4gKiBBZnRlciByZWFkaW5nIGV2ZW50cyBmcm9tIGFsbCBDbG91ZFdhdGNoIGxvZyBncm91cHNcbiAqIGhvdyBsb25nIHNob3VsZCB3ZSB3YWl0IHRvIHJlYWQgbW9yZSBldmVudHMuXG4gKlxuICogSWYgdGhlcmUgaXMgc29tZSBlcnJvciB3aXRoIHJlYWRpbmcgZXZlbnRzIChpLmUuIFRocm90dGxlKVxuICogdGhlbiB0aGlzIGlzIGFsc28gaG93IGxvbmcgd2Ugd2FpdCB1bnRpbCB3ZSB0cnkgYWdhaW5cbiAqL1xuY29uc3QgU0xFRVAgPSAyXzAwMDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgQ2xvdWRXYXRjaCBMb2cgRXZlbnQgdGhhdCB3aWxsIGJlXG4gKiBwcmludGVkIHRvIHRoZSB0ZXJtaW5hbFxuICovXG5pbnRlcmZhY2UgQ2xvdWRXYXRjaExvZ0V2ZW50IHtcbiAgLyoqXG4gICAqIFRoZSBsb2cgZXZlbnQgbWVzc2FnZVxuICAgKi9cbiAgcmVhZG9ubHkgbWVzc2FnZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgbG9nIGdyb3VwXG4gICAqL1xuICByZWFkb25seSBsb2dHcm91cE5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHRpbWUgYXQgd2hpY2ggdGhlIGV2ZW50IG9jY3VycmVkXG4gICAqL1xuICByZWFkb25seSB0aW1lc3RhbXA6IERhdGU7XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiB0cmFja2luZyBpbmZvcm1hdGlvbiBvbiB0aGUgbG9nIGdyb3VwcyB0aGF0IGFyZVxuICogYmVpbmcgbW9uaXRvcmVkXG4gKi9cbmludGVyZmFjZSBMb2dHcm91cHNBY2Nlc3NTZXR0aW5ncyB7XG4gIC8qKlxuICAgKiBUaGUgU0RLIGZvciBhIGdpdmVuIGVudmlyb25tZW50IChhY2NvdW50L3JlZ2lvbilcbiAgICovXG4gIHJlYWRvbmx5IHNkazogSVNESztcblxuICAvKipcbiAgICogQSBtYXAgb2YgbG9nIGdyb3VwcyBhbmQgYXNzb2NpYXRlZCBzdGFydFRpbWUgaW4gYSBnaXZlbiBhY2NvdW50LlxuICAgKlxuICAgKiBUaGUgbW9uaXRvciB3aWxsIHJlYWQgZXZlbnRzIGZyb20gdGhlIGxvZyBncm91cCBzdGFydGluZyBhdCB0aGVcbiAgICogYXNzb2NpYXRlZCBzdGFydFRpbWVcbiAgICovXG4gIHJlYWRvbmx5IGxvZ0dyb3Vwc1N0YXJ0VGltZXM6IHsgW2xvZ0dyb3VwTmFtZTogc3RyaW5nXTogbnVtYmVyIH07XG59XG5cbmV4cG9ydCBjbGFzcyBDbG91ZFdhdGNoTG9nRXZlbnRNb25pdG9yIHtcbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hpY2ggZXZlbnRzIG5vdCB0byBkaXNwbGF5XG4gICAqL1xuICBwcml2YXRlIHN0YXJ0VGltZTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgZW52aXJvbm1lbnQgKGFjY291bnQ6cmVnaW9uKSB0byBMb2dHcm91cHNBY2Nlc3NTZXR0aW5nc1xuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBlbnZzTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MgPSBuZXcgTWFwPHN0cmluZywgTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3M+KCk7XG5cbiAgcHJpdmF0ZSBhY3RpdmUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihzdGFydFRpbWU/OiBEYXRlKSB7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWU/LmdldFRpbWUoKSA/PyBEYXRlLm5vdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlc3VtZSByZWFkaW5nL3ByaW50aW5nIGV2ZW50c1xuICAgKi9cbiAgcHVibGljIGFjdGl2YXRlKCk6IHZvaWQge1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLnNjaGVkdWxlTmV4dFRpY2soMCk7XG4gIH1cblxuICAvKipcbiAgICogZGVhY3RpdmF0ZXMgdGhlIG1vbml0b3Igc28gbm8gbmV3IGV2ZW50cyBhcmUgcmVhZFxuICAgKiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB3aGVuIHdlIGFyZSBpbiB0aGUgbWlkZGxlIG9mIHBlcmZvcm1pbmcgYSBkZXBsb3ltZW50XG4gICAqIGFuZCBkb24ndCB3YW50IHRvIGludGVyd2VhdmUgYWxsIHRoZSBsb2dzIHRvZ2V0aGVyIHdpdGggdGhlIENGTlxuICAgKiBkZXBsb3ltZW50IGxvZ3NcbiAgICpcbiAgICogQWxzbyByZXNldHMgdGhlIHN0YXJ0IHRpbWUgdG8gYmUgd2hlbiB0aGUgbmV3IGRlcGxveW1lbnQgd2FzIHRyaWdnZXJlZFxuICAgKiBhbmQgY2xlYXJzIHRoZSBsaXN0IG9mIHRyYWNrZWQgbG9nIGdyb3Vwc1xuICAgKi9cbiAgcHVibGljIGRlYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5lbnZzTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIENsb3VkV2F0Y2ggbG9nIGdyb3VwcyB0byByZWFkIGxvZyBldmVudHMgZnJvbS5cbiAgICogU2luY2Ugd2UgY291bGQgYmUgd2F0Y2hpbmcgbXVsdGlwbGUgc3RhY2tzIHRoYXQgZGVwbG95IHRvXG4gICAqIG11bHRpcGxlIGVudmlyb25tZW50cyAoYWNjb3VudCtyZWdpb24pLCB3ZSBuZWVkIHRvIHN0b3JlIGEgbGlzdCBvZiBsb2cgZ3JvdXBzXG4gICAqIHBlciBlbnYgYWxvbmcgd2l0aCB0aGUgU0RLIG9iamVjdCB0aGF0IGhhcyBhY2Nlc3MgdG8gcmVhZCBmcm9tXG4gICAqIHRoYXQgZW52aXJvbm1lbnQuXG4gICAqL1xuICBwdWJsaWMgYWRkTG9nR3JvdXBzKGVudjogY3hhcGkuRW52aXJvbm1lbnQsIHNkazogSVNESywgbG9nR3JvdXBOYW1lczogc3RyaW5nW10pOiB2b2lkIHtcbiAgICBjb25zdCBhd3NFbnYgPSBgJHtlbnYuYWNjb3VudH06JHtlbnYucmVnaW9ufWA7XG4gICAgY29uc3QgbG9nR3JvdXBzU3RhcnRUaW1lcyA9IGxvZ0dyb3VwTmFtZXMucmVkdWNlKChhY2MsIGdyb3VwTmFtZSkgPT4ge1xuICAgICAgYWNjW2dyb3VwTmFtZV0gPSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30gYXMgeyBbbG9nR3JvdXBOYW1lOiBzdHJpbmddOiBudW1iZXIgfSk7XG4gICAgdGhpcy5lbnZzTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3Muc2V0KGF3c0Vudiwge1xuICAgICAgc2RrLFxuICAgICAgbG9nR3JvdXBzU3RhcnRUaW1lczoge1xuICAgICAgICAuLi50aGlzLmVudnNMb2dHcm91cHNBY2Nlc3NTZXR0aW5ncy5nZXQoYXdzRW52KT8ubG9nR3JvdXBzU3RhcnRUaW1lcyxcbiAgICAgICAgLi4ubG9nR3JvdXBzU3RhcnRUaW1lcyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHNjaGVkdWxlTmV4dFRpY2soc2xlZXA6IG51bWJlcik6IHZvaWQge1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdm9pZCh0aGlzLnRpY2soKSksIHNsZWVwKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgdGljaygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBldmVudHMgPSBmbGF0dGVuKGF3YWl0IHRoaXMucmVhZE5ld0V2ZW50cygpKTtcbiAgICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5wcmludChldmVudCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcignRXJyb3Igb2NjdXJyZWQgd2hpbGUgbW9uaXRvcmluZyBsb2dzOiAlcycsIGUpO1xuICAgIH1cblxuICAgIHRoaXMuc2NoZWR1bGVOZXh0VGljayhTTEVFUCk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgYWxsIG5ldyBsb2cgZXZlbnRzIGZyb20gYSBzZXQgb2YgQ2xvdWRXYXRjaCBMb2cgR3JvdXBzXG4gICAqIGluIHBhcmFsbGVsXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlYWROZXdFdmVudHMoKTogUHJvbWlzZTxBcnJheTxBcnJheTxDbG91ZFdhdGNoTG9nRXZlbnQ+Pj4ge1xuICAgIGNvbnN0IHByb21pc2VzOiBBcnJheTxQcm9taXNlPEFycmF5PENsb3VkV2F0Y2hMb2dFdmVudD4+PiA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2V0dGluZ3Mgb2YgdGhpcy5lbnZzTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgT2JqZWN0LmtleXMoc2V0dGluZ3MubG9nR3JvdXBzU3RhcnRUaW1lcykpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnJlYWRFdmVudHNGcm9tTG9nR3JvdXAoc2V0dGluZ3MsIGdyb3VwKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH1cblxuICAvKipcbiAgICogUHJpbnQgb3V0IGEgY2xvdWR3YXRjaCBldmVudFxuICAgKi9cbiAgcHJpdmF0ZSBwcmludChldmVudDogQ2xvdWRXYXRjaExvZ0V2ZW50KTogdm9pZCB7XG4gICAgcHJpbnQodXRpbC5mb3JtYXQoJ1slc10gJXMgJXMnLFxuICAgICAgY2hhbGsuYmx1ZShldmVudC5sb2dHcm91cE5hbWUpLFxuICAgICAgY2hhbGsueWVsbG93KGV2ZW50LnRpbWVzdGFtcC50b0xvY2FsZVRpbWVTdHJpbmcoKSksXG4gICAgICBldmVudC5tZXNzYWdlLnRyaW0oKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIGFsbCBuZXcgbG9nIGV2ZW50cyBmcm9tIGEgQ2xvdWRXYXRjaCBMb2cgR3JvdXBcbiAgICogc3RhcnRpbmcgYXQgZWl0aGVyIHRoZSB0aW1lIHRoZSBob3Rzd2FwIHdhcyB0cmlnZ2VyZWQgb3JcbiAgICogd2hlbiB0aGUgbGFzdCBldmVudCB3YXMgcmVhZCBvbiB0aGUgcHJldmlvdXMgdGlja1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZWFkRXZlbnRzRnJvbUxvZ0dyb3VwKFxuICAgIGxvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzOiBMb2dHcm91cHNBY2Nlc3NTZXR0aW5ncyxcbiAgICBsb2dHcm91cE5hbWU6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxBcnJheTxDbG91ZFdhdGNoTG9nRXZlbnQ+PiB7XG4gICAgY29uc3QgZXZlbnRzOiBDbG91ZFdhdGNoTG9nRXZlbnRbXSA9IFtdO1xuXG4gICAgLy8gbG9nIGV2ZW50cyBmcm9tIHNvbWUgc2VydmljZSBhcmUgaW5nZXN0ZWQgZmFzdGVyIHRoYW4gb3RoZXJzXG4gICAgLy8gc28gd2UgbmVlZCB0byB0cmFjayB0aGUgc3RhcnQvZW5kIHRpbWUgZm9yIGVhY2ggbG9nIGdyb3VwIGluZGl2aWR1YWxseVxuICAgIC8vIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIHByb2Nlc3MgYWxsIGV2ZW50cyBmcm9tIGVhY2ggbG9nIGdyb3VwXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gbG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MubG9nR3JvdXBzU3RhcnRUaW1lc1tsb2dHcm91cE5hbWVdID8/IHRoaXMuc3RhcnRUaW1lO1xuICAgIGxldCBlbmRUaW1lID0gc3RhcnRUaW1lO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGxvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzLnNkay5jbG91ZFdhdGNoTG9ncygpLmZpbHRlckxvZ0V2ZW50cyh7XG4gICAgICAgIGxvZ0dyb3VwTmFtZTogbG9nR3JvdXBOYW1lLFxuICAgICAgICBsaW1pdDogMTAwLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgIH0pLnByb21pc2UoKTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkRXZlbnRzID0gcmVzcG9uc2UuZXZlbnRzID8/IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGZpbHRlcmVkRXZlbnRzKSB7XG4gICAgICAgIGlmIChldmVudC5tZXNzYWdlKSB7XG4gICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogZXZlbnQubWVzc2FnZSxcbiAgICAgICAgICAgIGxvZ0dyb3VwTmFtZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZXZlbnQudGltZXN0YW1wID8gbmV3IERhdGUoZXZlbnQudGltZXN0YW1wKSA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZXZlbnQudGltZXN0YW1wICYmIGVuZFRpbWUgPCBldmVudC50aW1lc3RhbXApIHtcbiAgICAgICAgICAgIGVuZFRpbWUgPSBldmVudC50aW1lc3RhbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGhhdmUgPiAxMDAgZXZlbnRzIGxldCB0aGUgdXNlciBrbm93IHNvbWVcbiAgICAgIC8vIG1lc3NhZ2VzIGhhdmUgYmVlbiBzdXByZXNzZWQuIFdlIGFyZSBlc3NlbnRpYWxseVxuICAgICAgLy8gc2hvd2luZyB0aGVtIGEgc2FtcGxpbmcgKDEwMDAwIGV2ZW50cyBwcmludGVkIG91dCBpcyBub3QgdmVyeSB1c2VmdWwpXG4gICAgICBpZiAoZmlsdGVyZWRFdmVudHMubGVuZ3RoID4gMCAmJiByZXNwb25zZS5uZXh0VG9rZW4pIHtcbiAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgIG1lc3NhZ2U6ICc+Pj4gYHdhdGNoYCBzaG93cyBvbmx5IHRoZSBmaXJzdCAxMDAgbG9nIG1lc3NhZ2VzIC0gdGhlIHJlc3QgaGF2ZSBiZWVuIHRydW5jYXRlZC4uLicsXG4gICAgICAgICAgbG9nR3JvdXBOYW1lLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoZW5kVGltZSksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHdpdGggTGFtYmRhIGZ1bmN0aW9ucyB0aGUgQ2xvdWRXYXRjaCBpcyBub3QgY3JlYXRlZFxuICAgICAgLy8gdW50aWwgc29tZXRoaW5nIGlzIGxvZ2dlZCwgc28ganVzdCBrZWVwIHBvbGxpbmcgdW50aWxcbiAgICAgIC8vIHRoZXJlIGlzIHNvbXRoaW5nIHRvIGZpbmRcbiAgICAgIGlmIChlLmNvZGUgPT09ICdSZXNvdXJjZU5vdEZvdW5kRXhjZXB0aW9uJykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBsb2dHcm91cHNBY2Nlc3NTZXR0aW5ncy5sb2dHcm91cHNTdGFydFRpbWVzW2xvZ0dyb3VwTmFtZV0gPSBlbmRUaW1lICsgMTtcbiAgICByZXR1cm4gZXZlbnRzO1xuICB9XG59XG4iXX0=