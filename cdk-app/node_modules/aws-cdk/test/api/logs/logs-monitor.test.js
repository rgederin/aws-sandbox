"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const logs_monitor_1 = require("../../../lib/api/logs/logs-monitor");
const aws_1 = require("../../integ/helpers/aws");
const mock_sdk_1 = require("../../util/mock-sdk");
let sdk;
let stderrMock;
let monitor;
beforeEach(() => {
    monitor = new logs_monitor_1.CloudWatchLogEventMonitor(new Date(T100));
    stderrMock = jest.spyOn(process.stderr, 'write').mockImplementation(() => { return true; });
    sdk = new mock_sdk_1.MockSdk();
});
afterAll(() => {
    stderrMock.mockRestore();
    monitor.deactivate();
});
test('continue to the next page if it exists', async () => {
    // GIVEN
    const eventDate = new Date(T0 + 102 * 1000);
    sdk.stubCloudWatchLogs({
        filterLogEvents() {
            return {
                events: [event(102, 'message', eventDate)],
                nextToken: 'some-token',
            };
        },
    });
    monitor.addLogGroups({
        name: 'name',
        account: '11111111111',
        region: 'us-east-1',
    }, sdk, ['loggroup']);
    // WHEN
    monitor.activate();
    // need time for the log processing to occur
    await aws_1.sleep(1000);
    // THEN
    const expectedLocaleTimeString = eventDate.toLocaleTimeString();
    expect(stderrMock).toHaveBeenCalledTimes(2);
    expect(stderrMock.mock.calls[0][0]).toContain(`[${chalk_1.blue('loggroup')}] ${chalk_1.yellow(expectedLocaleTimeString)} message`);
    expect(stderrMock.mock.calls[1][0]).toContain(`[${chalk_1.blue('loggroup')}] ${chalk_1.yellow(expectedLocaleTimeString)} >>> \`watch\` shows only the first 100 log messages - the rest have been truncated...`);
});
const T0 = 1597837230504;
const T100 = T0 + 100 * 1000;
function event(nr, message, timestamp) {
    return {
        eventId: `${nr}`,
        message,
        timestamp: timestamp.getTime(),
        ingestionTime: timestamp.getTime(),
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9ncy1tb25pdG9yLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJsb2dzLW1vbml0b3IudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGlDQUFxQztBQUNyQyxxRUFBK0U7QUFDL0UsaURBQWdEO0FBQ2hELGtEQUE4QztBQUU5QyxJQUFJLEdBQVksQ0FBQztBQUNqQixJQUFJLFVBQTRCLENBQUM7QUFDakMsSUFBSSxPQUFrQyxDQUFDO0FBQ3ZDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7SUFDZCxPQUFPLEdBQUcsSUFBSSx3Q0FBeUIsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3hELFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFLEdBQUcsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1RixHQUFHLEdBQUcsSUFBSSxrQkFBTyxFQUFFLENBQUM7QUFDdEIsQ0FBQyxDQUFDLENBQUM7QUFFSCxRQUFRLENBQUMsR0FBRyxFQUFFO0lBQ1osVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3pCLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQztBQUN2QixDQUFDLENBQUMsQ0FBQztBQUVILElBQUksQ0FBQyx3Q0FBd0MsRUFBRSxLQUFLLElBQUksRUFBRTtJQUN4RCxRQUFRO0lBQ1IsTUFBTSxTQUFTLEdBQUcsSUFBSSxJQUFJLENBQUMsRUFBRSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQztJQUM1QyxHQUFHLENBQUMsa0JBQWtCLENBQUM7UUFDckIsZUFBZTtZQUNiLE9BQU87Z0JBQ0wsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7Z0JBQzFDLFNBQVMsRUFBRSxZQUFZO2FBQ3hCLENBQUM7UUFDSixDQUFDO0tBQ0YsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxDQUFDLFlBQVksQ0FDbEI7UUFDRSxJQUFJLEVBQUUsTUFBTTtRQUNaLE9BQU8sRUFBRSxhQUFhO1FBQ3RCLE1BQU0sRUFBRSxXQUFXO0tBQ3BCLEVBQ0QsR0FBRyxFQUNILENBQUMsVUFBVSxDQUFDLENBQ2IsQ0FBQztJQUNGLE9BQU87SUFDUCxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbkIsNENBQTRDO0lBQzVDLE1BQU0sV0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRWxCLE9BQU87SUFDUCxNQUFNLHdCQUF3QixHQUFHLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0lBQ2hFLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQzNDLElBQUksWUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLGNBQU0sQ0FBQyx3QkFBd0IsQ0FBQyxVQUFVLENBQ3BFLENBQUM7SUFDRixNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQzNDLElBQUksWUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLGNBQU0sQ0FBQyx3QkFBd0IsQ0FBQyx3RkFBd0YsQ0FDbEosQ0FBQztBQUNKLENBQUMsQ0FBQyxDQUFDO0FBRUgsTUFBTSxFQUFFLEdBQUcsYUFBYSxDQUFDO0FBQ3pCLE1BQU0sSUFBSSxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDO0FBQzdCLFNBQVMsS0FBSyxDQUFDLEVBQVUsRUFBRSxPQUFlLEVBQUUsU0FBZTtJQUN6RCxPQUFPO1FBQ0wsT0FBTyxFQUFFLEdBQUcsRUFBRSxFQUFFO1FBQ2hCLE9BQU87UUFDUCxTQUFTLEVBQUUsU0FBUyxDQUFDLE9BQU8sRUFBRTtRQUM5QixhQUFhLEVBQUUsU0FBUyxDQUFDLE9BQU8sRUFBRTtLQUNuQyxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJsdWUsIHllbGxvdyB9IGZyb20gJ2NoYWxrJztcbmltcG9ydCB7IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IgfSBmcm9tICcuLi8uLi8uLi9saWIvYXBpL2xvZ3MvbG9ncy1tb25pdG9yJztcbmltcG9ydCB7IHNsZWVwIH0gZnJvbSAnLi4vLi4vaW50ZWcvaGVscGVycy9hd3MnO1xuaW1wb3J0IHsgTW9ja1NkayB9IGZyb20gJy4uLy4uL3V0aWwvbW9jay1zZGsnO1xuXG5sZXQgc2RrOiBNb2NrU2RrO1xubGV0IHN0ZGVyck1vY2s6IGplc3QuU3B5SW5zdGFuY2U7XG5sZXQgbW9uaXRvcjogQ2xvdWRXYXRjaExvZ0V2ZW50TW9uaXRvcjtcbmJlZm9yZUVhY2goKCkgPT4ge1xuICBtb25pdG9yID0gbmV3IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IobmV3IERhdGUoVDEwMCkpO1xuICBzdGRlcnJNb2NrID0gamVzdC5zcHlPbihwcm9jZXNzLnN0ZGVyciwgJ3dyaXRlJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHsgcmV0dXJuIHRydWU7IH0pO1xuICBzZGsgPSBuZXcgTW9ja1NkaygpO1xufSk7XG5cbmFmdGVyQWxsKCgpID0+IHtcbiAgc3RkZXJyTW9jay5tb2NrUmVzdG9yZSgpO1xuICBtb25pdG9yLmRlYWN0aXZhdGUoKTtcbn0pO1xuXG50ZXN0KCdjb250aW51ZSB0byB0aGUgbmV4dCBwYWdlIGlmIGl0IGV4aXN0cycsIGFzeW5jICgpID0+IHtcbiAgLy8gR0lWRU5cbiAgY29uc3QgZXZlbnREYXRlID0gbmV3IERhdGUoVDAgKyAxMDIgKiAxMDAwKTtcbiAgc2RrLnN0dWJDbG91ZFdhdGNoTG9ncyh7XG4gICAgZmlsdGVyTG9nRXZlbnRzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnRzOiBbZXZlbnQoMTAyLCAnbWVzc2FnZScsIGV2ZW50RGF0ZSldLFxuICAgICAgICBuZXh0VG9rZW46ICdzb21lLXRva2VuJyxcbiAgICAgIH07XG4gICAgfSxcbiAgfSk7XG4gIG1vbml0b3IuYWRkTG9nR3JvdXBzKFxuICAgIHtcbiAgICAgIG5hbWU6ICduYW1lJyxcbiAgICAgIGFjY291bnQ6ICcxMTExMTExMTExMScsXG4gICAgICByZWdpb246ICd1cy1lYXN0LTEnLFxuICAgIH0sXG4gICAgc2RrLFxuICAgIFsnbG9nZ3JvdXAnXSxcbiAgKTtcbiAgLy8gV0hFTlxuICBtb25pdG9yLmFjdGl2YXRlKCk7XG4gIC8vIG5lZWQgdGltZSBmb3IgdGhlIGxvZyBwcm9jZXNzaW5nIHRvIG9jY3VyXG4gIGF3YWl0IHNsZWVwKDEwMDApO1xuXG4gIC8vIFRIRU5cbiAgY29uc3QgZXhwZWN0ZWRMb2NhbGVUaW1lU3RyaW5nID0gZXZlbnREYXRlLnRvTG9jYWxlVGltZVN0cmluZygpO1xuICBleHBlY3Qoc3RkZXJyTW9jaykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICBleHBlY3Qoc3RkZXJyTW9jay5tb2NrLmNhbGxzWzBdWzBdKS50b0NvbnRhaW4oXG4gICAgYFske2JsdWUoJ2xvZ2dyb3VwJyl9XSAke3llbGxvdyhleHBlY3RlZExvY2FsZVRpbWVTdHJpbmcpfSBtZXNzYWdlYCxcbiAgKTtcbiAgZXhwZWN0KHN0ZGVyck1vY2subW9jay5jYWxsc1sxXVswXSkudG9Db250YWluKFxuICAgIGBbJHtibHVlKCdsb2dncm91cCcpfV0gJHt5ZWxsb3coZXhwZWN0ZWRMb2NhbGVUaW1lU3RyaW5nKX0gPj4+IFxcYHdhdGNoXFxgIHNob3dzIG9ubHkgdGhlIGZpcnN0IDEwMCBsb2cgbWVzc2FnZXMgLSB0aGUgcmVzdCBoYXZlIGJlZW4gdHJ1bmNhdGVkLi4uYCxcbiAgKTtcbn0pO1xuXG5jb25zdCBUMCA9IDE1OTc4MzcyMzA1MDQ7XG5jb25zdCBUMTAwID0gVDAgKyAxMDAgKiAxMDAwO1xuZnVuY3Rpb24gZXZlbnQobnI6IG51bWJlciwgbWVzc2FnZTogc3RyaW5nLCB0aW1lc3RhbXA6IERhdGUpOiBBV1MuQ2xvdWRXYXRjaExvZ3MuRmlsdGVyZWRMb2dFdmVudCB7XG4gIHJldHVybiB7XG4gICAgZXZlbnRJZDogYCR7bnJ9YCxcbiAgICBtZXNzYWdlLFxuICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLmdldFRpbWUoKSxcbiAgICBpbmdlc3Rpb25UaW1lOiB0aW1lc3RhbXAuZ2V0VGltZSgpLFxuICB9O1xufVxuIl19