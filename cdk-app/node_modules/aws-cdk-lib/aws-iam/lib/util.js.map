{
  "version": 3,
  "sources": ["util.ts"],
  "sourcesContent": ["import { captureStackTrace, DefaultTokenResolver, IPostProcessor, IResolvable, IResolveContext, Lazy, StringConcat, Token, Tokenization } from '../../core';\nimport { IConstruct } from 'constructs';\nimport { IPolicy } from './policy';\n\nconst MAX_POLICY_NAME_LEN = 128;\n\nexport const LITERAL_STRING_KEY = 'LiteralString';\n\nexport function undefinedIfEmpty(f: () => string[]): string[] {\n  return Lazy.list({\n    produce: () => {\n      const array = f();\n      return (array && array.length > 0) ? array : undefined;\n    },\n  });\n}\n\n/**\n * Used to generate a unique policy name based on the policy resource construct.\n * The logical ID of the resource is a great candidate as long as it doesn't exceed\n * 128 characters, so we take the last 128 characters (in order to make sure the hash\n * is there).\n */\nexport function generatePolicyName(scope: IConstruct, logicalId: string): string {\n  // as logicalId is itself a Token, resolve it first\n  const resolvedLogicalId = Tokenization.resolve(logicalId, {\n    scope,\n    resolver: new DefaultTokenResolver(new StringConcat()),\n  });\n  return lastNCharacters(resolvedLogicalId, MAX_POLICY_NAME_LEN);\n}\n\n/**\n * Returns a string composed of the last n characters of str.\n * If str is shorter than n, returns str.\n *\n * @param str the string to return the last n characters of\n * @param n how many characters to return\n */\nfunction lastNCharacters(str: string, n: number) {\n  const startIndex = Math.max(str.length - n, 0);\n  return str.substring(startIndex, str.length);\n}\n\n/**\n * Helper class that maintains the set of attached policies for a principal.\n */\nexport class AttachedPolicies {\n  private policies = new Array<IPolicy>();\n\n  /**\n   * Adds a policy to the list of attached policies.\n   *\n   * If this policy is already, attached, returns false.\n   * If there is another policy attached with the same name, throws an exception.\n   */\n  public attach(policy: IPolicy) {\n    if (this.policies.find(p => p === policy)) {\n      return; // already attached\n    }\n\n    if (this.policies.find(p => p.policyName === policy.policyName)) {\n      throw new Error(`A policy named \"${policy.policyName}\" is already attached`);\n    }\n\n    this.policies.push(policy);\n  }\n}\n\n/**\n * Merge two dictionaries that represent IAM principals\n *\n * Does an in-place merge.\n */\nexport function mergePrincipal(target: { [key: string]: string[] }, source: { [key: string]: string[] }) {\n  // If one represents a literal string, the other one must be empty\n  if ((LITERAL_STRING_KEY in source && !isEmptyObject(target)) ||\n    (LITERAL_STRING_KEY in target && !isEmptyObject(source))) {\n    throw new Error(`Cannot merge principals ${JSON.stringify(target)} and ${JSON.stringify(source)}; if one uses a literal principal string the other one must be empty`);\n  }\n\n  for (const key of Object.keys(source)) {\n    target[key] = target[key] ?? [];\n\n    let value = source[key];\n    if (!Array.isArray(value)) {\n      value = [value];\n    }\n\n    target[key].push(...value);\n  }\n\n  return target;\n}\n\n/**\n * Lazy string set token that dedupes entries\n *\n * Needs to operate post-resolve, because the inputs could be\n * `[ '${Token[TOKEN.9]}', '${Token[TOKEN.10]}', '${Token[TOKEN.20]}' ]`, which\n * still all resolve to the same string value.\n *\n * Needs to JSON.stringify() results because strings could resolve to literal\n * strings but could also resolve to `{ Fn::Join: [...] }`.\n */\nexport class UniqueStringSet implements IResolvable, IPostProcessor {\n  public static from(fn: () => string[]) {\n    return Token.asList(new UniqueStringSet(fn));\n  }\n\n  public readonly creationStack: string[];\n\n  private constructor(private readonly fn: () => string[]) {\n    this.creationStack = captureStackTrace();\n  }\n\n  public resolve(context: IResolveContext) {\n    context.registerPostProcessor(this);\n    return this.fn();\n  }\n\n  public postProcess(input: any, _context: IResolveContext) {\n    if (!Array.isArray(input)) { return input; }\n    if (input.length === 0) { return undefined; }\n\n    const uniq: Record<string, any> = {};\n    for (const el of input) {\n      uniq[JSON.stringify(el)] = el;\n    }\n    return Object.values(uniq);\n  }\n\n  public toString(): string {\n    return Token.asString(this);\n  }\n}\n\nfunction isEmptyObject(x: { [key: string]: any }): boolean {\n  return Object.keys(x).length === 0;\n}\n"],
  "mappings": "kOAAA,KAAA,QAAA,QAAA,cAIM,oBAAsB,IAEf,QAAA,mBAAqB,gBAElC,0BAAiC,EAAiB,CAChD,MAAO,QAAA,KAAK,KAAK,CACf,QAAS,IAAK,CACZ,KAAM,OAAQ,IACd,MAAQ,QAAS,MAAM,OAAS,EAAK,MAAQ,UAJnD,QAAA,iBAAA,iBAeA,4BAAmC,MAAmB,UAAiB,CAErE,KAAM,mBAAoB,OAAA,aAAa,QAAQ,UAAW,CACxD,MACA,SAAU,GAAI,QAAA,qBAAqB,GAAI,QAAA,gBAEzC,MAAO,iBAAgB,kBAAmB,qBAN5C,QAAA,mBAAA,mBAgBA,yBAAyB,IAAa,EAAS,CAC7C,KAAM,YAAa,KAAK,IAAI,IAAI,OAAS,EAAG,GAC5C,MAAO,KAAI,UAAU,WAAY,IAAI,QAMvC,sBAA6B,CAA7B,aAAA,CACU,KAAA,SAAW,GAAI,OAQhB,OAAO,OAAe,CAC3B,GAAI,MAAK,SAAS,KAAK,GAAK,IAAM,QAIlC,IAAI,KAAK,SAAS,KAAK,GAAK,EAAE,aAAe,OAAO,YAClD,KAAM,IAAI,OAAM,mBAAmB,OAAO,mCAG5C,KAAK,SAAS,KAAK,UAlBvB,QAAA,iBAAA,iBA2BA,wBAA+B,OAAqC,OAAmC,QAErG,GAAK,QAAA,qBAAsB,SAAU,CAAC,cAAc,SACjD,QAAA,qBAAsB,SAAU,CAAC,cAAc,QAChD,KAAM,IAAI,OAAM,2BAA2B,KAAK,UAAU,eAAe,KAAK,UAAU,+EAG1F,SAAW,OAAO,QAAO,KAAK,QAAS,CACrC,OAAO,KAAI,IAAG,OAAO,QAAI,MAAA,KAAA,OAAA,GAAI,GAE7B,GAAI,OAAQ,OAAO,KACnB,AAAK,MAAM,QAAQ,QACjB,OAAQ,CAAC,QAGX,OAAO,KAAK,KAAK,GAAG,OAGtB,MAAO,QAlBT,QAAA,eAAA,eA+BA,qBAA4B,CAO1B,YAAqC,GAAkB,CAAlB,KAAA,GAAA,GACnC,KAAK,cAAgB,OAAA,0BAPT,MAAK,GAAkB,CACnC,MAAO,QAAA,MAAM,OAAO,GAAI,iBAAgB,KASnC,QAAQ,QAAwB,CACrC,eAAQ,sBAAsB,MACvB,KAAK,KAGP,YAAY,MAAY,SAAyB,CACtD,GAAI,CAAC,MAAM,QAAQ,OAAU,MAAO,OACpC,GAAI,MAAM,SAAW,EAAK,OAE1B,KAAM,MAA4B,GAClC,SAAW,MAAM,OACf,KAAK,KAAK,UAAU,KAAO,GAE7B,MAAO,QAAO,OAAO,MAGhB,UAAQ,CACb,MAAO,QAAA,MAAM,SAAS,OA5B1B,QAAA,gBAAA,gBAgCA,uBAAuB,EAAyB,CAC9C,MAAO,QAAO,KAAK,GAAG,SAAW",
  "names": []
}
