{
  "version": 3,
  "sources": ["index.js"],
  "sourcesContent": ["'use strict';\n\nconst aws = require('aws-sdk');\n\nconst defaultSleep = function (ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\n\n// These are used for test purposes only\nlet defaultResponseURL;\nlet waiter;\nlet sleep = defaultSleep;\nlet random = Math.random;\nlet maxAttempts = 10;\n\n/**\n * Upload a CloudFormation response object to S3.\n *\n * @param {object} event the Lambda event payload received by the handler function\n * @param {object} context the Lambda context received by the handler function\n * @param {string} responseStatus the response status, either 'SUCCESS' or 'FAILED'\n * @param {string} physicalResourceId CloudFormation physical resource ID\n * @param {object} [responseData] arbitrary response data object\n * @param {string} [reason] reason for failure, if any, to convey to the user\n * @returns {Promise} Promise that is resolved on success, or rejected on connection error or HTTP error response\n */\nlet report = function (event, context, responseStatus, physicalResourceId, responseData, reason) {\n  return new Promise((resolve, reject) => {\n    const https = require('https');\n    const { URL } = require('url');\n\n    var responseBody = JSON.stringify({\n      Status: responseStatus,\n      Reason: reason,\n      PhysicalResourceId: physicalResourceId || context.logStreamName,\n      StackId: event.StackId,\n      RequestId: event.RequestId,\n      LogicalResourceId: event.LogicalResourceId,\n      Data: responseData\n    });\n\n    const parsedUrl = new URL(event.ResponseURL || defaultResponseURL);\n    const options = {\n      hostname: parsedUrl.hostname,\n      port: 443,\n      path: parsedUrl.pathname + parsedUrl.search,\n      method: 'PUT',\n      headers: {\n        'Content-Type': '',\n        'Content-Length': responseBody.length\n      }\n    };\n\n    https.request(options)\n      .on('error', reject)\n      .on('response', res => {\n        res.resume();\n        if (res.statusCode >= 400) {\n          reject(new Error(`Server returned error ${res.statusCode}: ${res.statusMessage}`));\n        } else {\n          resolve();\n        }\n      })\n      .end(responseBody, 'utf8');\n  });\n};\n\n/**\n * Requests a public certificate from AWS Certificate Manager, using DNS validation.\n * The hosted zone ID must refer to a **public** Route53-managed DNS zone that is authoritative\n * for the suffix of the certificate's Common Name (CN).  For example, if the CN is\n * `*.example.com`, the hosted zone ID must point to a Route 53 zone authoritative\n * for `example.com`.\n *\n * @param {string} requestId the CloudFormation request ID\n * @param {string} domainName the Common Name (CN) field for the requested certificate\n * @param {string} hostedZoneId the Route53 Hosted Zone ID\n * @param {map} tags Tags to add to the requested certificate\n * @returns {string} Validated certificate ARN\n */\nconst requestCertificate = async function (requestId, domainName, subjectAlternativeNames, hostedZoneId, region, route53Endpoint, tags) {\n  const crypto = require('crypto');\n  const acm = new aws.ACM({ region });\n  const route53 = route53Endpoint ? new aws.Route53({ endpoint: route53Endpoint }) : new aws.Route53();\n  if (waiter) {\n    // Used by the test suite, since waiters aren't mockable yet\n    route53.waitFor = acm.waitFor = waiter;\n  }\n\n  console.log(`Requesting certificate for ${domainName}`);\n\n  const reqCertResponse = await acm.requestCertificate({\n    DomainName: domainName,\n    SubjectAlternativeNames: subjectAlternativeNames,\n    IdempotencyToken: crypto.createHash('sha256').update(requestId).digest('hex').substr(0, 32),\n    ValidationMethod: 'DNS'\n  }).promise();\n\n  console.log(`Certificate ARN: ${reqCertResponse.CertificateArn}`);\n\n\n  if (!!tags) {\n    const result = Array.from(Object.entries(tags)).map(([Key, Value]) => ({ Key, Value }))\n\n    await acm.addTagsToCertificate({\n      CertificateArn: reqCertResponse.CertificateArn,\n      Tags: result,\n    }).promise();\n  }\n\n  console.log('Waiting for ACM to provide DNS records for validation...');\n\n  let records = [];\n  for (let attempt = 0; attempt < maxAttempts && !records.length; attempt++) {\n    const { Certificate } = await acm.describeCertificate({\n      CertificateArn: reqCertResponse.CertificateArn\n    }).promise();\n\n    records = getDomainValidationRecords(Certificate);\n    if (!records.length) {\n      // Exponential backoff with jitter based on 200ms base\n      // component of backoff fixed to ensure minimum total wait time on\n      // slow targets.\n      const base = Math.pow(2, attempt);\n      await sleep(random() * base * 50 + base * 150);\n    }\n  }\n  if (!records.length) {\n    throw new Error(`Response from describeCertificate did not contain DomainValidationOptions after ${maxAttempts} attempts.`)\n  }\n\n  console.log(`Upserting ${records.length} DNS records into zone ${hostedZoneId}:`);\n\n  await commitRoute53Records(route53, records, hostedZoneId);\n\n  console.log('Waiting for validation...');\n  await acm.waitFor('certificateValidated', {\n    // Wait up to 9 minutes and 30 seconds\n    $waiter: {\n      delay: 30,\n      maxAttempts: 19\n    },\n    CertificateArn: reqCertResponse.CertificateArn\n  }).promise();\n\n  return reqCertResponse.CertificateArn;\n};\n\n/**\n * Deletes a certificate from AWS Certificate Manager (ACM) by its ARN.\n * If the certificate does not exist, the function will return normally.\n *\n * @param {string} arn The certificate ARN\n */\nconst deleteCertificate = async function (arn, region, hostedZoneId, route53Endpoint, cleanupRecords) {\n  const acm = new aws.ACM({ region });\n  const route53 = route53Endpoint ? new aws.Route53({ endpoint: route53Endpoint }) : new aws.Route53();\n  if (waiter) {\n    // Used by the test suite, since waiters aren't mockable yet\n    route53.waitFor = acm.waitFor = waiter;\n  }\n\n  try {\n    console.log(`Waiting for certificate ${arn} to become unused`);\n\n    let inUseByResources;\n    let records = [];\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      const { Certificate } = await acm.describeCertificate({\n        CertificateArn: arn\n      }).promise();\n\n      if (cleanupRecords) {\n        records = getDomainValidationRecords(Certificate);\n      }\n      inUseByResources = Certificate.InUseBy || [];\n\n      if (inUseByResources.length || !records.length) {\n        // Exponential backoff with jitter based on 200ms base\n        // component of backoff fixed to ensure minimum total wait time on\n        // slow targets.\n        const base = Math.pow(2, attempt);\n        await sleep(random() * base * 50 + base * 150);\n      } else {\n        break;\n      }\n    }\n\n    if (inUseByResources.length) {\n      throw new Error(`Response from describeCertificate did not contain an empty InUseBy list after ${maxAttempts} attempts.`)\n    }\n    if (cleanupRecords && !records.length) {\n      throw new Error(`Response from describeCertificate did not contain DomainValidationOptions after ${maxAttempts} attempts.`)\n    }\n\n    console.log(`Deleting certificate ${arn}`);\n\n    await acm.deleteCertificate({\n      CertificateArn: arn\n    }).promise();\n\n    if (cleanupRecords) {\n      console.log(`Deleting ${records.length} DNS records from zone ${hostedZoneId}:`);\n\n      await commitRoute53Records(route53, records, hostedZoneId, 'DELETE');\n    }\n\n  } catch (err) {\n    if (err.name !== 'ResourceNotFoundException') {\n      throw err;\n    }\n  }\n};\n\n/**\n * Retrieve the unique domain validation options as records to be upserted (or deleted) from Route53.\n *\n * Returns an empty array ([]) if the domain validation options is empty or the records are not yet ready.\n */\nfunction getDomainValidationRecords(certificate) {\n  const options = certificate.DomainValidationOptions || [];\n  // Ensure all records are ready; there is (at least a theory there's) a chance of a partial response here in rare cases.\n  if (options.length > 0 && options.every(opt => opt && !!opt.ResourceRecord)) {\n    // some alternative names will produce the same validation record\n    // as the main domain (eg. example.com + *.example.com)\n    // filtering duplicates to avoid errors with adding the same record\n    // to the route53 zone twice\n    const unique = options\n      .map((val) => val.ResourceRecord)\n      .reduce((acc, cur) => {\n        acc[cur.Name] = cur;\n        return acc;\n      }, {});\n    return Object.keys(unique).sort().map(key => unique[key]);\n  }\n  return [];\n}\n\n/**\n * Execute Route53 ChangeResourceRecordSets for a set of records within a Hosted Zone,\n * and wait for the records to commit. Defaults to an 'UPSERT' action.\n */\nasync function commitRoute53Records(route53, records, hostedZoneId, action = 'UPSERT') {\n  const changeBatch = await route53.changeResourceRecordSets({\n    ChangeBatch: {\n      Changes: records.map((record) => {\n        console.log(`${record.Name} ${record.Type} ${record.Value}`);\n        return {\n          Action: action,\n          ResourceRecordSet: {\n            Name: record.Name,\n            Type: record.Type,\n            TTL: 60,\n            ResourceRecords: [{\n              Value: record.Value\n            }]\n          }\n        };\n      }),\n    },\n    HostedZoneId: hostedZoneId\n  }).promise();\n\n  console.log('Waiting for DNS records to commit...');\n  await route53.waitFor('resourceRecordSetsChanged', {\n    // Wait up to 5 minutes\n    $waiter: {\n      delay: 30,\n      maxAttempts: 10\n    },\n    Id: changeBatch.ChangeInfo.Id\n  }).promise();\n}\n\n/**\n * Main handler, invoked by Lambda\n */\nexports.certificateRequestHandler = async function (event, context) {\n  var responseData = {};\n  var physicalResourceId;\n  var certificateArn;\n\n  try {\n    switch (event.RequestType) {\n      case 'Create':\n      case 'Update':\n        certificateArn = await requestCertificate(\n          event.RequestId,\n          event.ResourceProperties.DomainName,\n          event.ResourceProperties.SubjectAlternativeNames,\n          event.ResourceProperties.HostedZoneId,\n          event.ResourceProperties.Region,\n          event.ResourceProperties.Route53Endpoint,\n          event.ResourceProperties.Tags,\n        );\n        responseData.Arn = physicalResourceId = certificateArn;\n        break;\n      case 'Delete':\n        physicalResourceId = event.PhysicalResourceId;\n        // If the resource didn't create correctly, the physical resource ID won't be the\n        // certificate ARN, so don't try to delete it in that case.\n        if (physicalResourceId.startsWith('arn:')) {\n          await deleteCertificate(\n            physicalResourceId,\n            event.ResourceProperties.Region,\n            event.ResourceProperties.HostedZoneId,\n            event.ResourceProperties.Route53Endpoint,\n            event.ResourceProperties.CleanupRecords === \"true\",\n          );\n        }\n        break;\n      default:\n        throw new Error(`Unsupported request type ${event.RequestType}`);\n    }\n\n    console.log(`Uploading SUCCESS response to S3...`);\n    await report(event, context, 'SUCCESS', physicalResourceId, responseData);\n    console.log('Done.');\n  } catch (err) {\n    console.log(`Caught error ${err}. Uploading FAILED message to S3.`);\n    await report(event, context, 'FAILED', physicalResourceId, null, err.message);\n  }\n};\n\n/**\n * @private\n */\nexports.withReporter = function (reporter) {\n  report = reporter;\n};\n\n/**\n * @private\n */\nexports.withDefaultResponseURL = function (url) {\n  defaultResponseURL = url;\n};\n\n/**\n * @private\n */\nexports.withWaiter = function (w) {\n  waiter = w;\n};\n\n/**\n * @private\n */\nexports.resetWaiter = function () {\n  waiter = undefined;\n};\n\n/**\n * @private\n */\nexports.withSleep = function (s) {\n  sleep = s;\n}\n\n/**\n * @private\n */\nexports.resetSleep = function () {\n  sleep = defaultSleep;\n}\n\n/**\n * @private\n */\nexports.withRandom = function (r) {\n  random = r;\n}\n\n/**\n * @private\n */\nexports.resetRandom = function () {\n  random = Math.random;\n}\n\n/**\n * @private\n */\nexports.withMaxAttempts = function (ma) {\n  maxAttempts = ma;\n}\n\n/**\n * @private\n */\nexports.resetMaxAttempts = function () {\n  maxAttempts = 10;\n}\n"],
  "mappings": "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",
  "names": []
}
