{
  "version": 3,
  "sources": ["rendering.ts"],
  "sourcesContent": ["import { IMetric } from '../metric-types';\nimport { DropEmptyObjectAtTheEndOfAnArray } from './drop-empty-object-at-the-end-of-an-array-token';\nimport { accountIfDifferentFromStack, regionIfDifferentFromStack } from './env-tokens';\nimport { dispatchMetric, metricKey } from './metric-util';\nimport { dropUndefined } from './object';\n\n/**\n * Return the JSON structure which represents these metrics in a graph.\n *\n * Depending on the metric type (stat or expression), one `Metric` object\n * can render to multiple time series.\n *\n * - Top-level metrics will be rendered visibly, additionally added metrics will\n *   be rendered invisibly.\n * - IDs used in math expressions need to be either globally unique, or refer to the same\n *   metric object.\n *\n * This will be called by GraphWidget, no need for clients to call this.\n */\nexport function allMetricsGraphJson(left: IMetric[], right: IMetric[]): any[] {\n  // Add metrics to a set which will automatically expand them recursively,\n  // making sure to retain conflicting the visible one on conflicting metrics objects.\n  const mset = new MetricSet<string>();\n  mset.addTopLevel('left', ...left);\n  mset.addTopLevel('right', ...right);\n\n  // Render all metrics from the set.\n  return mset.entries.map(entry => new DropEmptyObjectAtTheEndOfAnArray(metricGraphJson(entry.metric, entry.tag, entry.id)));\n}\n\nfunction metricGraphJson(metric: IMetric, yAxis?: string, id?: string) {\n  const config = metric.toMetricConfig();\n\n  const ret: any[] = [];\n  const options: any = { ...config.renderingProperties };\n\n  dispatchMetric(metric, {\n    withStat(stat) {\n      ret.push(\n        stat.namespace,\n        stat.metricName,\n      );\n\n      // Dimensions\n      for (const dim of (stat.dimensions || [])) {\n        ret.push(dim.name, dim.value);\n      }\n\n      // Metric attributes that are rendered to graph options\n      if (stat.account) { options.accountId = accountIfDifferentFromStack(stat.account); }\n      if (stat.region) { options.region = regionIfDifferentFromStack(stat.region); }\n      if (stat.period && stat.period.toSeconds() !== 300) { options.period = stat.period.toSeconds(); }\n      if (stat.statistic && stat.statistic !== 'Average') { options.stat = stat.statistic; }\n    },\n\n    withExpression(expr) {\n      options.expression = expr.expression;\n      if (expr.searchAccount) { options.accountId = accountIfDifferentFromStack(expr.searchAccount); }\n      if (expr.searchRegion) { options.region = regionIfDifferentFromStack(expr.searchRegion); }\n      if (expr.period && expr.period !== 300) { options.period = expr.period; }\n    },\n  });\n\n  // Options\n  if (!yAxis) { options.visible = false; }\n  if (yAxis !== 'left') { options.yAxis = yAxis; }\n  if (id) { options.id = id; }\n\n  // If math expressions don't have a label (or an ID), they'll render with an unelegant\n  // autogenerated id (\"metric_alias0\"). Our ids may in the future also be autogenerated,\n  // so if an ME doesn't have a label, use its toString() as the label (renders the expression).\n  if (options.visible !== false && options.expression && !options.label) {\n    options.label = metric.toString();\n  }\n\n  const renderedOpts = dropUndefined(options);\n\n  if (Object.keys(renderedOpts).length !== 0) {\n    ret.push(renderedOpts);\n  }\n  return ret;\n}\n\n/**\n * A single metric in a MetricSet\n */\nexport interface MetricEntry<A> {\n  /**\n   * The metric object\n   */\n  readonly metric: IMetric;\n\n  /**\n   * The tag, added if the object is a primary metric\n   */\n  tag?: A;\n\n  /**\n   * ID for this metric object\n   */\n  id?: string;\n}\n\n/**\n * Contain a set of metrics, expanding math expressions\n *\n * \"Primary\" metrics (added via a top-level call) can be tagged with an additional value.\n */\nexport class MetricSet<A> {\n  private readonly metrics = new Array<MetricEntry<A>>();\n  private readonly metricById = new Map<string, MetricEntry<A>>();\n  private readonly metricByKey = new Map<string, MetricEntry<A>>();\n\n  /**\n   * Add the given set of metrics to this set\n   */\n  public addTopLevel(tag: A, ...metrics: IMetric[]) {\n    for (const metric of metrics) {\n      this.addOne(metric, tag);\n    }\n  }\n\n  /**\n   * Access all the accumulated timeseries entries\n   */\n  public get entries(): ReadonlyArray<MetricEntry<A>> {\n    return this.metrics;\n  }\n\n  /**\n   * Add a metric into the set\n   *\n   * The id may not be the same as a previous metric added, unless it's the same metric.\n   *\n   * It can be made visible, in which case the new \"metric\" object replaces the old\n   * one (and the new ones \"renderingPropertieS\" will be honored instead of the old\n   * one's).\n   */\n  private addOne(metric: IMetric, tag?: A, id?: string) {\n    const key = metricKey(metric);\n\n    let existingEntry: MetricEntry<A> | undefined;\n\n    // Try lookup existing by id if we have one\n    if (id) {\n      existingEntry = this.metricById.get(id);\n      if (existingEntry && metricKey(existingEntry.metric) !== key) {\n        throw new Error(`Cannot have two different metrics share the same id ('${id}') in one Alarm or Graph. Rename one of them.`);\n      }\n    }\n\n    if (!existingEntry) {\n      // Try lookup by metric if we didn't find one by id\n      existingEntry = this.metricByKey.get(key);\n\n      // If the one we found already has an id, it must be different from the id\n      // we're trying to add and we want to add a new metric. Pretend we didn't\n      // find one.\n      if (existingEntry?.id && id) { existingEntry = undefined; }\n    }\n\n    // Create a new entry if we didn't find one so far\n    let entry;\n    if (existingEntry) {\n      entry = existingEntry;\n    } else {\n      entry = { metric };\n      this.metrics.push(entry);\n      this.metricByKey.set(key, entry);\n    }\n\n    // If it didn't have an id but now we do, add one\n    if (!entry.id && id) {\n      entry.id = id;\n      this.metricById.set(id, entry);\n    }\n\n    // If it didn't have a tag but now we do, add one\n    if (!entry.tag && tag) {\n      entry.tag = tag;\n    }\n\n    // Recurse and add children\n    const conf = metric.toMetricConfig();\n    if (conf.mathExpression) {\n      for (const [subId, subMetric] of Object.entries(conf.mathExpression.usingMetrics)) {\n        this.addOne(subMetric, undefined, subId);\n      }\n    }\n  }\n}\n"],
  "mappings": "yHACA,KAAA,kDAAA,QAAA,oDACA,aAAA,QAAA,gBACA,cAAA,QAAA,iBACA,SAAA,QAAA,YAeA,6BAAoC,KAAiB,MAAgB,CAGnE,KAAM,MAAO,GAAI,WACjB,YAAK,YAAY,OAAQ,GAAG,MAC5B,KAAK,YAAY,QAAS,GAAG,OAGtB,KAAK,QAAQ,IAAI,OAAS,GAAI,kDAAA,iCAAiC,gBAAgB,MAAM,OAAQ,MAAM,IAAK,MAAM,MARvH,QAAA,oBAAA,oBAWA,yBAAyB,OAAiB,MAAgB,GAAW,CACnE,KAAM,QAAS,OAAO,iBAEhB,IAAa,GACb,QAAe,IAAK,OAAO,qBAEjC,cAAA,eAAe,OAAQ,CACrB,SAAS,KAAI,CACX,IAAI,KACF,KAAK,UACL,KAAK,YAIP,SAAW,OAAQ,MAAK,YAAc,GACpC,IAAI,KAAK,IAAI,KAAM,IAAI,OAIzB,AAAI,KAAK,SAAW,SAAQ,UAAY,aAAA,4BAA4B,KAAK,UACrE,KAAK,QAAU,SAAQ,OAAS,aAAA,2BAA2B,KAAK,SAChE,KAAK,QAAU,KAAK,OAAO,cAAgB,KAAO,SAAQ,OAAS,KAAK,OAAO,aAC/E,KAAK,WAAa,KAAK,YAAc,WAAa,SAAQ,KAAO,KAAK,YAG5E,eAAe,KAAI,CACjB,QAAQ,WAAa,KAAK,WACtB,KAAK,eAAiB,SAAQ,UAAY,aAAA,4BAA4B,KAAK,gBAC3E,KAAK,cAAgB,SAAQ,OAAS,aAAA,2BAA2B,KAAK,eACtE,KAAK,QAAU,KAAK,SAAW,KAAO,SAAQ,OAAS,KAAK,WAK/D,OAAS,SAAQ,QAAU,IAC5B,QAAU,QAAU,SAAQ,MAAQ,OACpC,IAAM,SAAQ,GAAK,IAKnB,QAAQ,UAAY,IAAS,QAAQ,YAAc,CAAC,QAAQ,OAC9D,SAAQ,MAAQ,OAAO,YAGzB,KAAM,cAAe,SAAA,cAAc,SAEnC,MAAI,QAAO,KAAK,cAAc,SAAW,GACvC,IAAI,KAAK,cAEJ,IA4BT,eAAsB,CAAtB,aAAA,CACmB,KAAA,QAAU,GAAI,OACd,KAAA,WAAa,GAAI,KACjB,KAAA,YAAc,GAAI,KAK5B,YAAY,OAAW,QAAkB,CAC9C,SAAW,UAAU,SACnB,KAAK,OAAO,OAAQ,QAOb,UAAO,CAChB,MAAO,MAAK,QAYN,OAAO,OAAiB,IAAS,GAAW,CAClD,KAAM,KAAM,cAAA,UAAU,QAEtB,GAAI,eAGJ,GAAI,IACF,eAAgB,KAAK,WAAW,IAAI,IAChC,eAAiB,cAAA,UAAU,cAAc,UAAY,KACvD,KAAM,IAAI,OAAM,yDAAyD,mDAI7E,AAAK,eAEH,eAAgB,KAAK,YAAY,IAAI,KAKjC,gBAAa,KAAA,OAAb,cAAe,KAAM,IAAM,eAAgB,SAIjD,GAAI,OACJ,AAAI,cACF,MAAQ,cAER,OAAQ,CAAE,QACV,KAAK,QAAQ,KAAK,OAClB,KAAK,YAAY,IAAI,IAAK,QAIxB,CAAC,MAAM,IAAM,IACf,OAAM,GAAK,GACX,KAAK,WAAW,IAAI,GAAI,QAItB,CAAC,MAAM,KAAO,KAChB,OAAM,IAAM,KAId,KAAM,MAAO,OAAO,iBACpB,GAAI,KAAK,eACP,SAAW,CAAC,MAAO,YAAc,QAAO,QAAQ,KAAK,eAAe,cAClE,KAAK,OAAO,UAAW,OAAW,QA9E1C,QAAA,UAAA",
  "names": []
}
