{
  "version": 3,
  "sources": ["toposort.ts"],
  "sourcesContent": ["import { GraphNode } from './graph';\n\nexport function printDependencyMap<A>(dependencies: Map<GraphNode<A>, Set<GraphNode<A>>>) {\n  const lines = ['---'];\n  for (const [k, vs] of dependencies.entries()) {\n    lines.push(`${k} -> ${Array.from(vs)}`);\n  }\n  // eslint-disable-next-line no-console\n  console.log(lines.join('\\n'));\n}\n\nexport function topoSort<A>(nodes: Set<GraphNode<A>>, dependencies: Map<GraphNode<A>, Set<GraphNode<A>>>): GraphNode<A>[][] {\n  const remaining = new Set<GraphNode<A>>(nodes);\n\n  const ret: GraphNode<A>[][] = [];\n  while (remaining.size > 0) {\n    // All elements with no more deps in the set can be ordered\n    const selectable = Array.from(remaining.values()).filter(e => {\n      if (!dependencies.has(e)) {\n        throw new Error(`No key for ${e}`);\n      }\n      return dependencies.get(e)!.size === 0;\n    });\n    selectable.sort((a, b) => a.id < b.id ? -1 : b.id < a.id ? 1 : 0);\n\n    // If we didn't make any progress, we got stuck\n    if (selectable.length === 0) {\n      const cycle = findCycle(dependencies);\n      throw new Error(`Dependency cycle in graph: ${cycle.map(n => n.id).join(' => ')}`);\n    }\n\n    ret.push(selectable);\n\n    for (const selected of selectable) {\n      remaining.delete(selected);\n      for (const depSet of dependencies.values()) {\n        depSet.delete(selected);\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Find cycles in a graph\n *\n * Not the fastest, but effective and should be rare\n */\nfunction findCycle<A>(deps: Map<GraphNode<A>, Set<GraphNode<A>>>): GraphNode<A>[] {\n  for (const node of deps.keys()) {\n    const cycle = recurse(node, [node]);\n    if (cycle) { return cycle; }\n  }\n  throw new Error('No cycle found. Assertion failure!');\n\n  function recurse(node: GraphNode<A>, path: GraphNode<A>[]): GraphNode<A>[] | undefined {\n    for (const dep of deps.get(node) ?? []) {\n      if (dep === path[0]) { return [...path, dep]; }\n\n      const cycle = recurse(dep, [...path, dep]);\n      if (cycle) { return cycle; }\n    }\n\n    return undefined;\n  }\n}"],
  "mappings": "uHAEA,4BAAsC,aAAkD,CACtF,KAAM,OAAQ,CAAC,OACf,SAAW,CAAC,EAAG,KAAO,cAAa,UACjC,MAAM,KAAK,GAAG,QAAQ,MAAM,KAAK,OAGnC,QAAQ,IAAI,MAAM,KAAK;IANzB,QAAA,mBAAA,mBASA,kBAA4B,MAA0B,aAAkD,CACtG,KAAM,WAAY,GAAI,KAAkB,OAElC,IAAwB,GAC9B,KAAO,UAAU,KAAO,GAAG,CAEzB,KAAM,YAAa,MAAM,KAAK,UAAU,UAAU,OAAO,GAAI,CAC3D,GAAI,CAAC,aAAa,IAAI,GACpB,KAAM,IAAI,OAAM,cAAc,KAEhC,MAAO,cAAa,IAAI,GAAI,OAAS,IAKvC,GAHA,WAAW,KAAK,CAAC,EAAG,IAAM,EAAE,GAAK,EAAE,GAAK,GAAK,EAAE,GAAK,EAAE,GAAK,EAAI,GAG3D,WAAW,SAAW,EAAG,CAC3B,KAAM,OAAQ,UAAU,cACxB,KAAM,IAAI,OAAM,8BAA8B,MAAM,IAAI,GAAK,EAAE,IAAI,KAAK,WAG1E,IAAI,KAAK,YAET,SAAW,YAAY,YAAY,CACjC,UAAU,OAAO,UACjB,SAAW,UAAU,cAAa,SAChC,OAAO,OAAO,WAKpB,MAAO,KA9BT,QAAA,SAAA,SAsCA,mBAAsB,KAA0C,CAC9D,SAAW,QAAQ,MAAK,OAAQ,CAC9B,KAAM,OAAQ,QAAQ,KAAM,CAAC,OAC7B,GAAI,MAAS,MAAO,OAEtB,KAAM,IAAI,OAAM,sCAEhB,iBAAiB,KAAoB,KAAoB,QACvD,SAAW,OAAG,IAAI,KAAK,IAAI,SAAK,MAAA,KAAA,OAAA,GAAI,GAAI,CACtC,GAAI,MAAQ,KAAK,GAAM,MAAO,CAAC,GAAG,KAAM,KAExC,KAAM,OAAQ,QAAQ,IAAK,CAAC,GAAG,KAAM,MACrC,GAAI,MAAS,MAAO",
  "names": []
}
