{
  "version": 3,
  "sources": ["cyclic.ts"],
  "sourcesContent": ["import { Resource, Template } from './template';\n\n/**\n * Check a template for cyclic dependencies\n *\n * This will make sure that we don't happily validate templates\n * in unit tests that wouldn't deploy to CloudFormation anyway.\n */\nexport function checkTemplateForCyclicDependencies(template: Template): void {\n  const logicalIds = new Set(Object.keys(template.Resources ?? {}));\n\n  const dependencies = new Map<string, Set<string>>();\n  for (const [logicalId, resource] of Object.entries(template.Resources ?? {})) {\n    dependencies.set(logicalId, intersect(findResourceDependencies(resource), logicalIds));\n  }\n\n  // We will now progressively remove entries from the map of 'dependencies' that have\n  // 0 elements in them. If we can't do that anymore and the map isn't empty, we\n  // have a cyclic dependency.\n  while (dependencies.size > 0) {\n    const free = Array.from(dependencies.entries()).filter(([_, deps]) => deps.size === 0);\n    if (free.length === 0) {\n      // Oops!\n      const cycle = findCycle(dependencies);\n\n      const cycleResources: any = {};\n      for (const logicalId of cycle) {\n        cycleResources[logicalId] = template.Resources?.[logicalId];\n      }\n\n      throw new Error(`Template is undeployable, these resources have a dependency cycle: ${cycle.join(' -> ')}:\\n\\n${JSON.stringify(cycleResources, undefined, 2)}`);\n    }\n\n    for (const [logicalId, _] of free) {\n      for (const deps of dependencies.values()) {\n        deps.delete(logicalId);\n      }\n      dependencies.delete(logicalId);\n    }\n  }\n}\n\nfunction findResourceDependencies(res: Resource): Set<string> {\n  return new Set([\n    ...toArray(res.DependsOn ?? []),\n    ...findExpressionDependencies(res.Properties),\n  ]);\n}\n\nfunction toArray<A>(x: A | A[]): A[] {\n  return Array.isArray(x) ? x : [x];\n}\n\nfunction findExpressionDependencies(obj: any): Set<string> {\n  const ret = new Set<string>();\n  recurse(obj);\n  return ret;\n\n  function recurse(x: any): void {\n    if (!x) { return; }\n    if (Array.isArray(x)) {\n      x.forEach(recurse);\n    }\n    if (typeof x === 'object') {\n      const keys = Object.keys(x);\n      if (keys.length === 1 && keys[0] === 'Ref') {\n        ret.add(x[keys[0]]);\n      } else if (keys.length === 1 && keys[0] === 'Fn::GetAtt') {\n        ret.add(x[keys[0]][0]);\n      } else if (keys.length === 1 && keys[0] === 'Fn::Sub') {\n        const argument = x[keys[0]];\n        const pattern = Array.isArray(argument) ? argument[0] : argument;\n\n        // pattern should always be a string, but we've encountered some cases in which\n        // it isn't. Better safeguard.\n        if (typeof pattern === 'string') {\n          for (const logId of logicalIdsInSubString(pattern)) {\n            ret.add(logId);\n          }\n        }\n        const contextDict = Array.isArray(argument) ? argument[1] : undefined;\n        if (contextDict && typeof contextDict === 'object') {\n          Object.values(contextDict).forEach(recurse);\n        }\n      } else {\n        Object.values(x).forEach(recurse);\n      }\n    }\n  }\n}\n\n/**\n * Return the logical IDs found in a {Fn::Sub} format string\n */\nfunction logicalIdsInSubString(x: string): string[] {\n  return analyzeSubPattern(x).flatMap((fragment) => {\n    switch (fragment.type) {\n      case 'getatt':\n      case 'ref':\n        return [fragment.logicalId];\n      case 'literal':\n        return [];\n    }\n  });\n}\n\n\nfunction analyzeSubPattern(pattern: string): SubFragment[] {\n  const ret: SubFragment[] = [];\n  let start = 0;\n\n  let ph0 = pattern.indexOf('${', start);\n  while (ph0 > -1) {\n    if (pattern[ph0 + 2] === '!') {\n      // \"${!\" means \"don't actually substitute\"\n      start = ph0 + 3;\n      ph0 = pattern.indexOf('${', start);\n      continue;\n    }\n\n    const ph1 = pattern.indexOf('}', ph0 + 2);\n    if (ph1 === -1) {\n      break;\n    }\n    const placeholder = pattern.substring(ph0 + 2, ph1);\n\n    if (ph0 > start) {\n      ret.push({ type: 'literal', content: pattern.substring(start, ph0) });\n    }\n    if (placeholder.includes('.')) {\n      const [logicalId, attr] = placeholder.split('.');\n      ret.push({ type: 'getatt', logicalId: logicalId!, attr: attr! });\n    } else {\n      ret.push({ type: 'ref', logicalId: placeholder });\n    }\n\n    start = ph1 + 1;\n    ph0 = pattern.indexOf('${', start);\n  }\n\n  if (start < pattern.length - 1) {\n    ret.push({ type: 'literal', content: pattern.substr(start) });\n  }\n\n  return ret;\n}\n\ntype SubFragment =\n  | { readonly type: 'literal'; readonly content: string }\n  | { readonly type: 'ref'; readonly logicalId: string }\n  | { readonly type: 'getatt'; readonly logicalId: string; readonly attr: string };\n\n\nfunction intersect<A>(xs: Set<A>, ys: Set<A>): Set<A> {\n  return new Set<A>(Array.from(xs).filter(x => ys.has(x)));\n}\n\n/**\n * Find cycles in a graph\n *\n * Not the fastest, but effective and should be rare\n */\nfunction findCycle(deps: ReadonlyMap<string, ReadonlySet<string>>): string[] {\n  for (const node of deps.keys()) {\n    const cycle = recurse(node, [node]);\n    if (cycle) { return cycle; }\n  }\n  throw new Error('No cycle found. Assertion failure!');\n\n  function recurse(node: string, path: string[]): string[] | undefined {\n    for (const dep of deps.get(node) ?? []) {\n      if (dep === path[0]) { return [...path, dep]; }\n\n      const cycle = recurse(dep, [...path, dep]);\n      if (cycle) { return cycle; }\n    }\n\n    return undefined;\n  }\n}"],
  "mappings": "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",
  "names": []
}
