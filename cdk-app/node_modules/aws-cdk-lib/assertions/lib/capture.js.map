{
  "version": 3,
  "sources": ["capture.ts"],
  "sourcesContent": ["import { Match } from '.';\nimport { Matcher, MatchResult } from './matcher';\nimport { Type, getType } from './private/type';\n\n/**\n * Capture values while matching templates.\n * Using an instance of this class within a Matcher will capture the matching value.\n * The `as*()` APIs on the instance can be used to get the captured value.\n */\nexport class Capture extends Matcher {\n  public readonly name: string;\n  /** @internal */\n  public _captured: any[] = [];\n  private idx = 0;\n\n  /**\n   * Initialize a new capture\n   * @param pattern a nested pattern or Matcher.\n   * If a nested pattern is provided `objectLike()` matching is applied.\n   */\n  constructor(private readonly pattern?: any) {\n    super();\n    this.name = 'Capture';\n  }\n\n  public test(actual: any): MatchResult {\n    const result = new MatchResult(actual);\n    if (actual == null) {\n      return result.recordFailure({\n        matcher: this,\n        path: [],\n        message: `Can only capture non-nullish values. Found ${actual}`,\n      });\n    }\n\n    if (this.pattern !== undefined) {\n      const innerMatcher = Matcher.isMatcher(this.pattern) ? this.pattern : Match.objectLike(this.pattern);\n      const innerResult = innerMatcher.test(actual);\n      if (innerResult.hasFailed()) {\n        return innerResult;\n      }\n    }\n\n    result.recordCapture({ capture: this, value: actual });\n    return result;\n  }\n\n  /**\n   * When multiple results are captured, move the iterator to the next result.\n   * @returns true if another capture is present, false otherwise\n   */\n  public next(): boolean {\n    if (this.idx < this._captured.length - 1) {\n      this.idx++;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Retrieve the captured value as a string.\n   * An error is generated if no value is captured or if the value is not a string.\n   */\n  public asString(): string {\n    this.validate();\n    const val = this._captured[this.idx];\n    if (getType(val) === 'string') {\n      return val;\n    }\n    this.reportIncorrectType('string');\n  }\n\n  /**\n   * Retrieve the captured value as a number.\n   * An error is generated if no value is captured or if the value is not a number.\n   */\n  public asNumber(): number {\n    this.validate();\n    const val = this._captured[this.idx];\n    if (getType(val) === 'number') {\n      return val;\n    }\n    this.reportIncorrectType('number');\n  }\n\n  /**\n   * Retrieve the captured value as a boolean.\n   * An error is generated if no value is captured or if the value is not a boolean.\n   */\n  public asBoolean(): boolean {\n    this.validate();\n    const val = this._captured[this.idx];\n    if (getType(val) === 'boolean') {\n      return val;\n    }\n    this.reportIncorrectType('boolean');\n  }\n\n  /**\n   * Retrieve the captured value as an array.\n   * An error is generated if no value is captured or if the value is not an array.\n   */\n  public asArray(): any[] {\n    this.validate();\n    const val = this._captured[this.idx];\n    if (getType(val) === 'array') {\n      return val;\n    }\n    this.reportIncorrectType('array');\n  }\n\n  /**\n   * Retrieve the captured value as a JSON object.\n   * An error is generated if no value is captured or if the value is not an object.\n   */\n  public asObject(): { [key: string]: any } {\n    this.validate();\n    const val = this._captured[this.idx];\n    if (getType(val) === 'object') {\n      return val;\n    }\n    this.reportIncorrectType('object');\n  }\n\n  private validate(): void {\n    if (this._captured.length === 0) {\n      throw new Error('No value captured');\n    }\n  }\n\n  private reportIncorrectType(expected: Type): never {\n    throw new Error(`Captured value is expected to be ${expected} but found ${getType(this._captured[this.idx])}. ` +\n      `Value is ${JSON.stringify(this._captured[this.idx], undefined, 2)}`);\n  }\n}"],
  "mappings": "mJAAA,GAAA,QAAA,KACA,UAAA,QAAA,aACA,OAAA,QAAA,kBAOA,qBAA6B,WAAA,OAAO,CAWlC,YAA6B,QAAa,CACxC,QAD2B,KAAA,QAAA,QARtB,KAAA,UAAmB,GAClB,KAAA,IAAM,EASZ,KAAK,KAAO,UAGP,KAAK,OAAW,CACrB,KAAM,QAAS,GAAI,WAAA,YAAY,QAC/B,GAAI,QAAU,KACZ,MAAO,QAAO,cAAc,CAC1B,QAAS,KACT,KAAM,GACN,QAAS,8CAA8C,WAI3D,GAAI,KAAK,UAAY,OAAW,CAE9B,KAAM,aAAc,AADC,WAAA,QAAQ,UAAU,KAAK,SAAW,KAAK,QAAU,GAAA,MAAM,WAAW,KAAK,UAC3D,KAAK,QACtC,GAAI,YAAY,YACd,MAAO,aAIX,cAAO,cAAc,CAAE,QAAS,KAAM,MAAO,SACtC,OAOF,MAAI,CACT,MAAI,MAAK,IAAM,KAAK,UAAU,OAAS,EACrC,MAAK,MACE,IAEF,GAOF,UAAQ,CACb,KAAK,WACL,KAAM,KAAM,KAAK,UAAU,KAAK,KAChC,GAAI,OAAA,QAAQ,OAAS,SACnB,MAAO,KAET,KAAK,oBAAoB,UAOpB,UAAQ,CACb,KAAK,WACL,KAAM,KAAM,KAAK,UAAU,KAAK,KAChC,GAAI,OAAA,QAAQ,OAAS,SACnB,MAAO,KAET,KAAK,oBAAoB,UAOpB,WAAS,CACd,KAAK,WACL,KAAM,KAAM,KAAK,UAAU,KAAK,KAChC,GAAI,OAAA,QAAQ,OAAS,UACnB,MAAO,KAET,KAAK,oBAAoB,WAOpB,SAAO,CACZ,KAAK,WACL,KAAM,KAAM,KAAK,UAAU,KAAK,KAChC,GAAI,OAAA,QAAQ,OAAS,QACnB,MAAO,KAET,KAAK,oBAAoB,SAOpB,UAAQ,CACb,KAAK,WACL,KAAM,KAAM,KAAK,UAAU,KAAK,KAChC,GAAI,OAAA,QAAQ,OAAS,SACnB,MAAO,KAET,KAAK,oBAAoB,UAGnB,UAAQ,CACd,GAAI,KAAK,UAAU,SAAW,EAC5B,KAAM,IAAI,OAAM,qBAIZ,oBAAoB,SAAc,CACxC,KAAM,IAAI,OAAM,oCAAoC,sBAAsB,OAAA,QAAQ,KAAK,UAAU,KAAK,mBACxF,KAAK,UAAU,KAAK,UAAU,KAAK,KAAM,OAAW,OA3HtE,QAAA,QAAA",
  "names": []
}
