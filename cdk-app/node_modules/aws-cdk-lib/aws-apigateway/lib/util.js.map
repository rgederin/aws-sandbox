{
  "version": 3,
  "sources": ["util.ts"],
  "sourcesContent": ["import { format as formatUrl } from 'url';\nimport * as jsonSchema from './json-schema';\n\nexport const ALL_METHODS = ['OPTIONS', 'GET', 'PUT', 'POST', 'DELETE', 'PATCH', 'HEAD'];\n\nconst ALLOWED_METHODS = ['ANY', ...ALL_METHODS];\n\nexport function validateHttpMethod(method: string, messagePrefix: string = '') {\n  if (!ALLOWED_METHODS.includes(method)) {\n    throw new Error(`${messagePrefix}Invalid HTTP method \"${method}\". Allowed methods: ${ALLOWED_METHODS.join(',')}`);\n  }\n}\n\nexport function parseMethodOptionsPath(originalPath: string): { resourcePath: string, httpMethod: string } {\n  if (!originalPath.startsWith('/')) {\n    throw new Error(`Method options path must start with '/': ${originalPath}`);\n  }\n\n  const path = originalPath.substr(1); // trim trailing '/'\n\n  const components = path.split('/');\n\n  if (components.length < 2) {\n    throw new Error(`Method options path must include at least two components: /{resource}/{method} (i.e. /foo/bar/GET): ${path}`);\n  }\n\n  const httpMethod = components.pop()!.toUpperCase(); // last component is an HTTP method\n  if (httpMethod !== '*') {\n    validateHttpMethod(httpMethod, `${originalPath}: `);\n  }\n\n  let resourcePath = '/~1' + components.join('~1');\n  if (components.length === 1 && components[0] === '*') {\n    resourcePath = '/*';\n  } else if (components.length === 1 && components[0] === '') {\n    resourcePath = '/';\n  }\n\n  return {\n    httpMethod,\n    resourcePath,\n  };\n}\n\nexport function parseAwsApiCall(path?: string, action?: string, actionParams?: { [key: string]: string }): { apiType: string, apiValue: string } {\n  if (actionParams && !action) {\n    throw new Error('\"actionParams\" requires that \"action\" will be set');\n  }\n\n  if (path && action) {\n    throw new Error(`\"path\" and \"action\" are mutually exclusive (path=\"${path}\", action=\"${action}\")`);\n  }\n\n  if (path) {\n    return {\n      apiType: 'path',\n      apiValue: path,\n    };\n  }\n\n  if (action) {\n    if (actionParams) {\n      action += '&' + formatUrl({ query: actionParams }).substr(1);\n    }\n\n    return {\n      apiType: 'action',\n      apiValue: action,\n    };\n  }\n\n  throw new Error('Either \"path\" or \"action\" are required');\n}\n\nexport function validateInteger(property: number | undefined, messagePrefix: string) {\n  if (property && !Number.isInteger(property)) {\n    throw new Error(`${messagePrefix} should be an integer`);\n  }\n}\n\nexport function validateDouble(property: number | undefined, messagePrefix: string) {\n  if (property && isNaN(property) && isNaN(parseFloat(property.toString()))) {\n    throw new Error(`${messagePrefix} should be an double`);\n  }\n}\n\nexport class JsonSchemaMapper {\n  /**\n   * Transforms naming of some properties to prefix with a $, where needed\n   * according to the JSON schema spec\n   * @param schema The JsonSchema object to transform for CloudFormation output\n   */\n  public static toCfnJsonSchema(schema: jsonSchema.JsonSchema): any {\n    const result = JsonSchemaMapper._toCfnJsonSchema(schema);\n    if (! ('$schema' in result)) {\n      result.$schema = jsonSchema.JsonSchemaVersion.DRAFT4;\n    }\n    return result;\n  }\n\n  private static readonly SchemaPropsWithPrefix: { [key: string]: string } = {\n    schema: '$schema',\n    ref: '$ref',\n    id: '$id',\n  };\n  // The value indicates whether direct children should be key-mapped.\n  private static readonly SchemaPropsWithUserDefinedChildren: { [key: string]: boolean } = {\n    definitions: true,\n    properties: true,\n    patternProperties: true,\n    dependencies: true,\n  };\n\n  private static _toCfnJsonSchema(schema: any, preserveKeys = false): any {\n    if (schema == null || typeof schema !== 'object') {\n      return schema;\n    }\n    if (Array.isArray(schema)) {\n      return schema.map(entry => JsonSchemaMapper._toCfnJsonSchema(entry));\n    }\n    return Object.assign({}, ...Object.entries(schema).map(([key, value]) => {\n      const mapKey = !preserveKeys && (key in JsonSchemaMapper.SchemaPropsWithPrefix);\n      const newKey = mapKey ? JsonSchemaMapper.SchemaPropsWithPrefix[key] : key;\n      // If keys were preserved, don't consider SchemaPropsWithUserDefinedChildren for those keys (they are user-defined!)\n      const newValue = JsonSchemaMapper._toCfnJsonSchema(value, !preserveKeys && JsonSchemaMapper.SchemaPropsWithUserDefinedChildren[key]);\n      return { [newKey]: newValue };\n    }));\n  }\n}\n"],
  "mappings": "yPAAA,KAAA,OAAA,QAAA,OACA,WAAA,QAAA,iBAEa,QAAA,YAAc,CAAC,UAAW,MAAO,MAAO,OAAQ,SAAU,QAAS,QAEhF,KAAM,iBAAkB,CAAC,MAAO,GAAG,QAAA,aAEnC,4BAAmC,OAAgB,cAAwB,GAAE,CAC3E,GAAI,CAAC,gBAAgB,SAAS,QAC5B,KAAM,IAAI,OAAM,GAAG,qCAAqC,6BAA6B,gBAAgB,KAAK,QAF9G,QAAA,mBAAA,mBAMA,gCAAuC,aAAoB,CACzD,GAAI,CAAC,aAAa,WAAW,KAC3B,KAAM,IAAI,OAAM,4CAA4C,gBAG9D,KAAM,MAAO,aAAa,OAAO,GAE3B,WAAa,KAAK,MAAM,KAE9B,GAAI,WAAW,OAAS,EACtB,KAAM,IAAI,OAAM,uGAAuG,QAGzH,KAAM,YAAa,WAAW,MAAO,cACrC,AAAI,aAAe,KACjB,mBAAmB,WAAY,GAAG,kBAGpC,GAAI,cAAe,MAAQ,WAAW,KAAK,MAC3C,MAAI,YAAW,SAAW,GAAK,WAAW,KAAO,IAC/C,aAAe,KACN,WAAW,SAAW,GAAK,WAAW,KAAO,IACtD,cAAe,KAGV,CACL,WACA,cA3BJ,QAAA,uBAAA,uBA+BA,yBAAgC,KAAe,OAAiB,aAAwC,CACtG,GAAI,cAAgB,CAAC,OACnB,KAAM,IAAI,OAAM,qDAGlB,GAAI,MAAQ,OACV,KAAM,IAAI,OAAM,qDAAqD,kBAAkB,YAGzF,GAAI,KACF,MAAO,CACL,QAAS,OACT,SAAU,MAId,GAAI,OACF,MAAI,eACF,SAAU,IAAM,MAAA,OAAU,CAAE,MAAO,eAAgB,OAAO,IAGrD,CACL,QAAS,SACT,SAAU,QAId,KAAM,IAAI,OAAM,0CA3BlB,QAAA,gBAAA,gBA8BA,yBAAgC,SAA8B,cAAqB,CACjF,GAAI,UAAY,CAAC,OAAO,UAAU,UAChC,KAAM,IAAI,OAAM,GAAG,sCAFvB,QAAA,gBAAA,gBAMA,wBAA+B,SAA8B,cAAqB,CAChF,GAAI,UAAY,MAAM,WAAa,MAAM,WAAW,SAAS,aAC3D,KAAM,IAAI,OAAM,GAAG,qCAFvB,QAAA,eAAA,eAMA,sBAA6B,OAMb,iBAAgB,OAA6B,CACzD,KAAM,QAAS,iBAAiB,iBAAiB,QACjD,MAAO,WAAa,SAClB,QAAO,QAAU,WAAW,kBAAkB,QAEzC,aAgBM,kBAAiB,OAAa,aAAe,GAAK,CAC/D,MAAI,SAAU,MAAQ,MAAO,SAAW,SAC/B,OAEL,MAAM,QAAQ,QACT,OAAO,IAAI,OAAS,iBAAiB,iBAAiB,QAExD,OAAO,OAAO,GAAI,GAAG,OAAO,QAAQ,QAAQ,IAAI,CAAC,CAAC,IAAK,SAAU,CAEtE,KAAM,QAAS,AADA,CAAC,cAAiB,MAAO,kBAAiB,sBACjC,iBAAiB,sBAAsB,KAAO,IAEhE,SAAW,iBAAiB,iBAAiB,MAAO,CAAC,cAAgB,iBAAiB,mCAAmC,MAC/H,MAAO,EAAG,QAAS,cAvCzB,QAAA,iBAAA,iBAc0B,iBAAA,sBAAmD,CACzE,OAAQ,UACR,IAAK,OACL,GAAI,OAGkB,iBAAA,mCAAiE,CACvF,YAAa,GACb,WAAY,GACZ,kBAAmB,GACnB,aAAc",
  "names": []
}
