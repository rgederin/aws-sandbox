{
  "version": 3,
  "sources": ["lazy.ts"],
  "sourcesContent": ["import { CDK_DEBUG, debugModeEnabled } from './debug';\nimport { IResolvable, IResolveContext } from './resolvable';\nimport { captureStackTrace } from './stack-trace';\nimport { Token } from './token';\n\n/**\n * Interface for lazy string producers\n */\nexport interface IStringProducer {\n  /**\n   * Produce the string value\n   */\n  produce(context: IResolveContext): string | undefined;\n}\n\n/**\n * Interface for (stable) lazy string producers\n */\nexport interface IStableStringProducer {\n  /**\n   * Produce the string value\n   */\n  produce(): string | undefined;\n}\n\n/**\n * Interface for lazy list producers\n */\nexport interface IListProducer {\n  /**\n   * Produce the list value\n   */\n  produce(context: IResolveContext): string[] | undefined;\n}\n\n/**\n * Interface for (stable) lazy list producers\n */\nexport interface IStableListProducer {\n  /**\n   * Produce the list value\n   */\n  produce(): string[] | undefined;\n}\n\n/**\n * Interface for lazy number producers\n */\nexport interface INumberProducer {\n  /**\n   * Produce the number value\n   */\n  produce(context: IResolveContext): number | undefined;\n}\n\n/**\n * Interface for (stable) lazy number producers\n */\nexport interface IStableNumberProducer {\n  /**\n   * Produce the number value\n   */\n  produce(): number | undefined;\n}\n\n/**\n * Interface for lazy untyped value producers\n */\nexport interface IAnyProducer {\n  /**\n   * Produce the value\n   */\n  produce(context: IResolveContext): any;\n}\n\n/**\n * Interface for (stable) lazy untyped value producers\n */\nexport interface IStableAnyProducer {\n  /**\n   * Produce the value\n   */\n  produce(): any;\n}\n\n/**\n * Options for creating a lazy string token\n */\nexport interface LazyStringValueOptions {\n  /**\n   * Use the given name as a display hint\n   *\n   * @default - No hint\n   */\n  readonly displayHint?: string;\n}\n\n/**\n * Options for creating a lazy list token\n */\nexport interface LazyListValueOptions {\n  /**\n   * Use the given name as a display hint\n   *\n   * @default - No hint\n   */\n  readonly displayHint?: string;\n\n  /**\n   * If the produced list is empty, return 'undefined' instead\n   *\n   * @default false\n   */\n  readonly omitEmpty?: boolean;\n}\n\n/**\n * Options for creating lazy untyped tokens\n */\nexport interface LazyAnyValueOptions {\n  /**\n   * Use the given name as a display hint\n   *\n   * @default - No hint\n   */\n  readonly displayHint?: string;\n\n  /**\n   * If the produced value is an array and it is empty, return 'undefined' instead\n   *\n   * @default false\n   */\n  readonly omitEmptyArray?: boolean;\n}\n\n/**\n * Lazily produce a value\n *\n * Can be used to return a string, list or numeric value whose actual value\n * will only be calculated later, during synthesis.\n */\nexport class Lazy {\n  /**\n   * Defer the calculation of a string value to synthesis time\n   *\n   * Use this if you want to render a string to a template whose actual value depends on\n   * some state mutation that may happen after the construct has been created.\n   *\n   * If you are simply looking to force a value to a `string` type and don't need\n   * the calculation to be deferred, use `Token.asString()` instead.\n   *\n   * @deprecated Use `Lazy.string()` or `Lazy.uncachedString()` instead.\n   */\n  public static stringValue(producer: IStringProducer, options: LazyStringValueOptions = {}) {\n    return Token.asString(new LazyString(producer, false), options);\n  }\n\n  /**\n   * Defer the one-time calculation of a string value to synthesis time\n   *\n   * Use this if you want to render a string to a template whose actual value depends on\n   * some state mutation that may happen after the construct has been created.\n   *\n   * If you are simply looking to force a value to a `string` type and don't need\n   * the calculation to be deferred, use `Token.asString()` instead.\n   *\n   * The inner function will only be invoked once, and the resolved value\n   * cannot depend on the Stack the Token is used in.\n   */\n  public static string(producer: IStableStringProducer, options: LazyStringValueOptions = {}) {\n    return Token.asString(new LazyString(producer, true), options);\n  }\n\n  /**\n   * Defer the calculation of a string value to synthesis time\n   *\n   * Use of this function is not recommended; unless you know you need it for sure, you\n   * probably don't. Use `Lazy.string()` instead.\n   *\n   * The inner function may be invoked multiple times during synthesis. You\n   * should only use this method if the returned value depends on variables\n   * that may change during the Aspect application phase of synthesis, or if\n   * the value depends on the Stack the value is being used in. Both of these\n   * cases are rare, and only ever occur for AWS Construct Library authors.\n   */\n  public static uncachedString(producer: IStringProducer, options: LazyStringValueOptions = {}) {\n    return Token.asString(new LazyString(producer, false), options);\n  }\n\n  /**\n   * Defer the one-time calculation of a number value to synthesis time\n   *\n   * Use this if you want to render a number to a template whose actual value depends on\n   * some state mutation that may happen after the construct has been created.\n   *\n   * If you are simply looking to force a value to a `number` type and don't need\n   * the calculation to be deferred, use `Token.asNumber()` instead.\n   *\n   * @deprecated Use `Lazy.number()` or `Lazy.uncachedNumber()` instead.\n   */\n  public static numberValue(producer: INumberProducer) {\n    return Token.asNumber(new LazyNumber(producer, false));\n  }\n\n  /**\n   * Defer the one-time calculation of a number value to synthesis time\n   *\n   * Use this if you want to render a number to a template whose actual value depends on\n   * some state mutation that may happen after the construct has been created.\n   *\n   * If you are simply looking to force a value to a `number` type and don't need\n   * the calculation to be deferred, use `Token.asNumber()` instead.\n   *\n   * The inner function will only be invoked once, and the resolved value\n   * cannot depend on the Stack the Token is used in.\n   */\n  public static number(producer: IStableNumberProducer) {\n    return Token.asNumber(new LazyNumber(producer, true));\n  }\n\n  /**\n   * Defer the calculation of a number value to synthesis time\n   *\n   * Use of this function is not recommended; unless you know you need it for sure, you\n   * probably don't. Use `Lazy.number()` instead.\n   *\n   * The inner function may be invoked multiple times during synthesis. You\n   * should only use this method if the returned value depends on variables\n   * that may change during the Aspect application phase of synthesis, or if\n   * the value depends on the Stack the value is being used in. Both of these\n   * cases are rare, and only ever occur for AWS Construct Library authors.\n   */\n  public static uncachedNumber(producer: INumberProducer) {\n    return Token.asNumber(new LazyNumber(producer, false));\n  }\n\n  /**\n   * Defer the one-time calculation of a list value to synthesis time\n   *\n   * Use this if you want to render a list to a template whose actual value depends on\n   * some state mutation that may happen after the construct has been created.\n   *\n   * If you are simply looking to force a value to a `string[]` type and don't need\n   * the calculation to be deferred, use `Token.asList()` instead.\n   *\n   * @deprecated Use `Lazy.list()` or `Lazy.uncachedList()` instead.\n   */\n  public static listValue(producer: IListProducer, options: LazyListValueOptions = {}) {\n    return Token.asList(new LazyList(producer, false, options), options);\n  }\n\n  /**\n   * Defer the calculation of a list value to synthesis time\n   *\n   * Use of this function is not recommended; unless you know you need it for sure, you\n   * probably don't. Use `Lazy.list()` instead.\n   *\n   * The inner function may be invoked multiple times during synthesis. You\n   * should only use this method if the returned value depends on variables\n   * that may change during the Aspect application phase of synthesis, or if\n   * the value depends on the Stack the value is being used in. Both of these\n   * cases are rare, and only ever occur for AWS Construct Library authors.\n   */\n  public static uncachedList(producer: IListProducer, options: LazyListValueOptions = {}) {\n    return Token.asList(new LazyList(producer, false, options), options);\n  }\n\n  /**\n   * Defer the one-time calculation of a list value to synthesis time\n   *\n   * Use this if you want to render a list to a template whose actual value depends on\n   * some state mutation that may happen after the construct has been created.\n   *\n   * If you are simply looking to force a value to a `string[]` type and don't need\n   * the calculation to be deferred, use `Token.asList()` instead.\n   *\n   * The inner function will only be invoked once, and the resolved value\n   * cannot depend on the Stack the Token is used in.\n   */\n  public static list(producer: IStableListProducer, options: LazyListValueOptions = {}) {\n    return Token.asList(new LazyList(producer, true, options), options);\n  }\n\n  /**\n   * Defer the one-time calculation of an arbitrarily typed value to synthesis time\n   *\n   * Use this if you want to render an object to a template whose actual value depends on\n   * some state mutation that may happen after the construct has been created.\n   *\n   * @deprecated Use `Lazy.any()` or `Lazy.uncachedAny()` instead.\n   */\n  public static anyValue(producer: IAnyProducer, options: LazyAnyValueOptions = {}): IResolvable {\n    return new LazyAny(producer, false, options);\n  }\n\n  /**\n   * Defer the one-time calculation of an arbitrarily typed value to synthesis time\n   *\n   * Use this if you want to render an object to a template whose actual value depends on\n   * some state mutation that may happen after the construct has been created.\n   *\n   * The inner function will only be invoked one time and cannot depend on\n   * resolution context.\n   */\n  public static any(producer: IStableAnyProducer, options: LazyAnyValueOptions = {}): IResolvable {\n    return new LazyAny(producer, true, options);\n  }\n\n  /**\n   * Defer the calculation of an untyped value to synthesis time\n   *\n   * Use of this function is not recommended; unless you know you need it for sure, you\n   * probably don't. Use `Lazy.any()` instead.\n   *\n   * The inner function may be invoked multiple times during synthesis. You\n   * should only use this method if the returned value depends on variables\n   * that may change during the Aspect application phase of synthesis, or if\n   * the value depends on the Stack the value is being used in. Both of these\n   * cases are rare, and only ever occur for AWS Construct Library authors.\n   */\n  public static uncachedAny(producer: IAnyProducer, options: LazyAnyValueOptions = {}): IResolvable {\n    return new LazyAny(producer, false, options);\n  }\n\n  private constructor() {\n  }\n}\n\n\ninterface ILazyProducer<A> {\n  produce(context: IResolveContext): A | undefined;\n}\n\nabstract class LazyBase<A> implements IResolvable {\n  public readonly creationStack: string[];\n  private _cached?: A;\n\n  constructor(private readonly producer: ILazyProducer<A>, private readonly cache: boolean) {\n    // Stack trace capture is conditionned to `debugModeEnabled()`, because\n    // lazies can be created in a fairly thrashy way, and the stack traces are\n    // large and slow to obtain; but are mostly useful only when debugging a\n    // resolution issue.\n    this.creationStack = debugModeEnabled()\n      ? captureStackTrace(this.constructor)\n      : [`Execute again with ${CDK_DEBUG}=true to capture stack traces`];\n  }\n\n  public resolve(context: IResolveContext) {\n    if (this.cache) {\n      return this._cached ?? (this._cached = this.producer.produce(context));\n    } else {\n      return this.producer.produce(context);\n    }\n  }\n\n  public toString() {\n    return Token.asString(this);\n  }\n\n  /**\n   * Turn this Token into JSON\n   *\n   * Called automatically when JSON.stringify() is called on a Token.\n   */\n  public toJSON(): any {\n    return '<unresolved-lazy>';\n  }\n\n}\n\nclass LazyString extends LazyBase<string> {\n}\n\nclass LazyNumber extends LazyBase<number> {\n}\n\nclass LazyList extends LazyBase<Array<string>> {\n  constructor(producer: IListProducer, cache: boolean, private readonly options: LazyListValueOptions = {}) {\n    super(producer, cache);\n  }\n\n  public resolve(context: IResolveContext) {\n    const resolved = super.resolve(context);\n    if (resolved?.length === 0 && this.options.omitEmpty) {\n      return undefined;\n    }\n    return resolved;\n  }\n}\n\nclass LazyAny extends LazyBase<any> {\n  constructor(producer: IAnyProducer, cache: boolean, private readonly options: LazyAnyValueOptions = {}) {\n    super(producer, cache);\n  }\n\n  public resolve(context: IResolveContext) {\n    const resolved = super.resolve(context);\n    if (Array.isArray(resolved) && resolved.length === 0 && this.options.omitEmptyArray) {\n      return undefined;\n    }\n    return resolved;\n  }\n}\n"],
  "mappings": "2MAAA,QAAA,QAAA,WAEA,cAAA,QAAA,iBACA,QAAA,QAAA,WA0IA,UAAiB,CAuLf,aAAA,QA3Kc,aAAY,SAA2B,QAAkC,GAAE,CACvF,MAAO,SAAA,MAAM,SAAS,GAAI,YAAW,SAAU,IAAQ,eAe3C,QAAO,SAAiC,QAAkC,GAAE,gJACjF,QAAA,MAAM,SAAS,GAAI,YAAW,SAAU,IAAO,eAe1C,gBAAe,SAA2B,QAAkC,GAAE,0IACnF,QAAA,MAAM,SAAS,GAAI,YAAW,SAAU,IAAQ,eAc3C,aAAY,SAAyB,CACjD,MAAO,SAAA,MAAM,SAAS,GAAI,YAAW,SAAU,WAenC,QAAO,SAA+B,4EAC3C,QAAA,MAAM,SAAS,GAAI,YAAW,SAAU,WAenC,gBAAe,SAAyB,sEAC7C,QAAA,MAAM,SAAS,GAAI,YAAW,SAAU,WAcnC,WAAU,SAAyB,QAAgC,GAAE,CACjF,MAAO,SAAA,MAAM,OAAO,GAAI,UAAS,SAAU,GAAO,SAAU,eAehD,cAAa,SAAyB,QAAgC,GAAE,sIAC7E,QAAA,MAAM,OAAO,GAAI,UAAS,SAAU,GAAO,SAAU,eAehD,MAAK,SAA+B,QAAgC,GAAE,4IAC3E,QAAA,MAAM,OAAO,GAAI,UAAS,SAAU,GAAM,SAAU,eAW/C,UAAS,SAAwB,QAA+B,GAAE,CAC9E,MAAO,IAAI,SAAQ,SAAU,GAAO,eAYxB,KAAI,SAA8B,QAA+B,GAAE,0IACxE,GAAI,SAAQ,SAAU,GAAM,eAevB,aAAY,SAAwB,QAA+B,GAAE,oIAC1E,GAAI,SAAQ,SAAU,GAAO,UApLxC,QAAA,KAAA,8EAgMA,cAAuB,CAIrB,YAA6B,SAA6C,MAAc,CAA3D,KAAA,SAAA,SAA6C,KAAA,MAAA,MAKxE,KAAK,cAAgB,QAAA,mBACjB,cAAA,kBAAkB,KAAK,aACvB,CAAC,sBAAsB,QAAA,0CAGtB,QAAQ,QAAwB,QACrC,MAAI,MAAK,MACP,IAAO,KAAK,WAAO,MAAA,KAAA,OAAA,GAAK,KAAK,QAAU,KAAK,SAAS,QAAQ,SAEtD,KAAK,SAAS,QAAQ,SAI1B,UAAQ,CACb,MAAO,SAAA,MAAM,SAAS,MAQjB,QAAM,CACX,MAAO,qBAKX,wBAAyB,SAAgB,EAGzC,wBAAyB,SAAgB,EAGzC,sBAAuB,SAAuB,CAC5C,YAAY,SAAyB,MAAiC,QAAgC,GAAE,CACtG,MAAM,SAAU,OADoD,KAAA,QAAA,QAI/D,QAAQ,QAAwB,CACrC,KAAM,UAAW,MAAM,QAAQ,SAC/B,GAAI,aAAQ,KAAA,OAAR,SAAU,UAAW,GAAK,KAAK,QAAQ,WAG3C,MAAO,WAIX,qBAAsB,SAAa,CACjC,YAAY,SAAwB,MAAiC,QAA+B,GAAE,CACpG,MAAM,SAAU,OADmD,KAAA,QAAA,QAI9D,QAAQ,QAAwB,CACrC,KAAM,UAAW,MAAM,QAAQ,SAC/B,GAAI,QAAM,QAAQ,WAAa,SAAS,SAAW,GAAK,KAAK,QAAQ,gBAGrE,MAAO",
  "names": []
}
