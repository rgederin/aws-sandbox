{
  "version": 3,
  "sources": ["_shared.ts"],
  "sourcesContent": ["import * as crypto from 'crypto';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as cxschema from '../../../cloud-assembly-schema';\nimport * as cxapi from '../../../cx-api';\nimport { Node, IConstruct } from 'constructs';\nimport { FileAssetSource, FileAssetPackaging } from '../assets';\nimport { Stack } from '../stack';\nimport { Token } from '../token';\nimport { ISynthesisSession } from './types';\n\n/**\n * Shared logic of writing stack artifact to the Cloud Assembly\n *\n * This logic is shared between StackSyntheses.\n *\n * It could have been a protected method on a base class, but it\n * uses `Partial<cxapi.AwsCloudFormationStackProperties>` in the\n * parameters (which is convenient so I can remain typesafe without\n * copy/pasting), and jsii will choke on this type.\n */\nexport function addStackArtifactToAssembly(\n  session: ISynthesisSession,\n  stack: Stack,\n  stackProps: Partial<cxschema.AwsCloudFormationStackProperties>,\n  additionalStackDependencies: string[]) {\n\n  // nested stack tags are applied at the AWS::CloudFormation::Stack resource\n  // level and are not needed in the cloud assembly.\n  if (stack.tags.hasTags()) {\n    stack.node.addMetadata(cxschema.ArtifactMetadataEntryType.STACK_TAGS, stack.tags.renderTags());\n  }\n\n  const deps = [\n    ...stack.dependencies.map(s => s.artifactId),\n    ...additionalStackDependencies,\n  ];\n  const meta = collectStackMetadata(stack);\n\n  // backwards compatibility since originally artifact ID was always equal to\n  // stack name the stackName attribute is optional and if it is not specified\n  // the CLI will use the artifact ID as the stack name. we *could have*\n  // always put the stack name here but wanted to minimize the risk around\n  // changes to the assembly manifest. so this means that as long as stack\n  // name and artifact ID are the same, the cloud assembly manifest will not\n  // change.\n  const stackNameProperty = stack.stackName === stack.artifactId\n    ? { }\n    : { stackName: stack.stackName };\n\n  const properties: cxschema.AwsCloudFormationStackProperties = {\n    templateFile: stack.templateFile,\n    terminationProtection: stack.terminationProtection,\n    tags: nonEmptyDict(stack.tags.tagValues()),\n    validateOnSynth: session.validateOnSynth,\n    ...stackProps,\n    ...stackNameProperty,\n  };\n\n  // add an artifact that represents this stack\n  session.assembly.addArtifact(stack.artifactId, {\n    type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,\n    environment: stack.environment,\n    properties,\n    dependencies: deps.length > 0 ? deps : undefined,\n    metadata: Object.keys(meta).length > 0 ? meta : undefined,\n    displayName: stack.node.path,\n  });\n}\n\n/**\n * Collect the metadata from a stack\n */\nfunction collectStackMetadata(stack: Stack) {\n  const output: { [id: string]: cxschema.MetadataEntry[] } = { };\n\n  visit(stack);\n\n  return output;\n\n  function visit(node: IConstruct) {\n    // break off if we reached a node that is not a child of this stack\n    const parent = findParentStack(node);\n    if (parent !== stack) {\n      return;\n    }\n\n    if (node.node.metadata.length > 0) {\n      // Make the path absolute\n      output[Node.PATH_SEP + node.node.path] = node.node.metadata.map(md => stack.resolve(md) as cxschema.MetadataEntry);\n    }\n\n    for (const child of node.node.children) {\n      visit(child);\n    }\n  }\n\n  function findParentStack(node: IConstruct): Stack | undefined {\n    if (node instanceof Stack && node.nestedStackParent === undefined) {\n      return node;\n    }\n\n    if (!node.node.scope) {\n      return undefined;\n    }\n\n    return findParentStack(node.node.scope);\n  }\n}\n\n/**\n * Hash a string\n */\nexport function contentHash(content: string) {\n  return crypto.createHash('sha256').update(content).digest('hex');\n}\n\n/**\n * Throw an error message about binding() if we don't have a value for x.\n *\n * This replaces the ! assertions we would need everywhere otherwise.\n */\nexport function assertBound<A>(x: A | undefined): asserts x is NonNullable<A> {\n  if (x === null && x === undefined) {\n    throw new Error('You must call bindStack() first');\n  }\n}\n\nfunction nonEmptyDict<A>(xs: Record<string, A>) {\n  return Object.keys(xs).length > 0 ? xs : undefined;\n}\n\n/**\n * A \"replace-all\" function that doesn't require us escaping a literal string to a regex\n */\nfunction replaceAll(s: string, search: string, replace: string) {\n  return s.split(search).join(replace);\n}\n\nexport class StringSpecializer {\n  constructor(private readonly stack: Stack, private readonly qualifier: string) {\n  }\n\n  /**\n   * Function to replace placeholders in the input string as much as possible\n   *\n   * We replace:\n   * - ${Qualifier}: always\n   * - ${AWS::AccountId}, ${AWS::Region}: only if we have the actual values available\n   * - ${AWS::Partition}: never, since we never have the actual partition value.\n   */\n  public specialize(s: string): string {\n    s = replaceAll(s, '${Qualifier}', this.qualifier);\n    return cxapi.EnvironmentPlaceholders.replace(s, {\n      region: resolvedOr(this.stack.region, cxapi.EnvironmentPlaceholders.CURRENT_REGION),\n      accountId: resolvedOr(this.stack.account, cxapi.EnvironmentPlaceholders.CURRENT_ACCOUNT),\n      partition: cxapi.EnvironmentPlaceholders.CURRENT_PARTITION,\n    });\n  }\n\n  /**\n   * Specialize only the qualifier\n   */\n  public qualifierOnly(s: string): string {\n    return replaceAll(s, '${Qualifier}', this.qualifier);\n  }\n}\n\n/**\n * Return the given value if resolved or fall back to a default\n */\nexport function resolvedOr<A>(x: string, def: A): string | A {\n  return Token.isUnresolved(x) ? def : x;\n}\n\nexport function stackTemplateFileAsset(stack: Stack, session: ISynthesisSession): FileAssetSource {\n  const templatePath = path.join(session.assembly.outdir, stack.templateFile);\n  const template = fs.readFileSync(templatePath, { encoding: 'utf-8' });\n\n  const sourceHash = contentHash(template);\n\n  return {\n    fileName: stack.templateFile,\n    packaging: FileAssetPackaging.FILE,\n    sourceHash,\n  };\n}\n"],
  "mappings": "kOAAA,KAAA,QAAA,QAAA,UACA,GAAA,QAAA,MACA,KAAA,QAAA,QACA,SAAA,QAAA,kCACA,MAAA,QAAA,mBACA,aAAA,QAAA,cACA,SAAA,QAAA,aACA,QAAA,QAAA,YACA,QAAA,QAAA,YAaA,oCACE,QACA,MACA,WACA,4BAAqC,CAIrC,AAAI,MAAM,KAAK,WACb,MAAM,KAAK,YAAY,SAAS,0BAA0B,WAAY,MAAM,KAAK,cAGnF,KAAM,MAAO,CACX,GAAG,MAAM,aAAa,IAAI,GAAK,EAAE,YACjC,GAAG,6BAEC,KAAO,qBAAqB,OAS5B,kBAAoB,MAAM,YAAc,MAAM,WAChD,GACA,CAAE,UAAW,MAAM,WAEjB,WAAwD,CAC5D,aAAc,MAAM,aACpB,sBAAuB,MAAM,sBAC7B,KAAM,aAAa,MAAM,KAAK,aAC9B,gBAAiB,QAAQ,mBACtB,cACA,mBAIL,QAAQ,SAAS,YAAY,MAAM,WAAY,CAC7C,KAAM,SAAS,aAAa,yBAC5B,YAAa,MAAM,YACnB,WACA,aAAc,KAAK,OAAS,EAAI,KAAO,OACvC,SAAU,OAAO,KAAK,MAAM,OAAS,EAAI,KAAO,OAChD,YAAa,MAAM,KAAK,OA7C5B,QAAA,2BAAA,2BAoDA,8BAA8B,MAAY,CACxC,KAAM,QAAqD,GAE3D,aAAM,OAEC,OAEP,eAAe,KAAgB,CAG7B,GAAI,AADW,gBAAgB,QAChB,MAIf,CAAI,KAAK,KAAK,SAAS,OAAS,GAE9B,QAAO,aAAA,KAAK,SAAW,KAAK,KAAK,MAAQ,KAAK,KAAK,SAAS,IAAI,IAAM,MAAM,QAAQ,MAGtF,SAAW,SAAS,MAAK,KAAK,SAC5B,MAAM,QAIV,yBAAyB,KAAgB,CACvC,GAAI,eAAgB,SAAA,OAAS,KAAK,oBAAsB,OACtD,MAAO,MAGT,GAAI,EAAC,KAAK,KAAK,MAIf,MAAO,iBAAgB,KAAK,KAAK,QAOrC,qBAA4B,QAAe,CACzC,MAAO,QAAO,WAAW,UAAU,OAAO,SAAS,OAAO,OAD5D,QAAA,YAAA,YASA,qBAA+B,EAAgB,CAC7C,GAAI,IAAM,MAAQ,IAAM,OACtB,KAAM,IAAI,OAAM,mCAFpB,QAAA,YAAA,YAMA,sBAAyB,GAAqB,CAC5C,MAAO,QAAO,KAAK,IAAI,OAAS,EAAI,GAAK,OAM3C,oBAAoB,EAAW,OAAgB,QAAe,CAC5D,MAAO,GAAE,MAAM,QAAQ,KAAK,SAG9B,uBAA8B,CAC5B,YAA6B,MAA+B,UAAiB,CAAhD,KAAA,MAAA,MAA+B,KAAA,UAAA,UAWrD,WAAW,EAAS,CACzB,SAAI,WAAW,EAAG,eAAgB,KAAK,WAChC,MAAM,wBAAwB,QAAQ,EAAG,CAC9C,OAAQ,WAAW,KAAK,MAAM,OAAQ,MAAM,wBAAwB,gBACpE,UAAW,WAAW,KAAK,MAAM,QAAS,MAAM,wBAAwB,iBACxE,UAAW,MAAM,wBAAwB,oBAOtC,cAAc,EAAS,CAC5B,MAAO,YAAW,EAAG,eAAgB,KAAK,YAzB9C,QAAA,kBAAA,kBAgCA,oBAA8B,EAAW,IAAM,CAC7C,MAAO,SAAA,MAAM,aAAa,GAAK,IAAM,EADvC,QAAA,WAAA,WAIA,gCAAuC,MAAc,QAA0B,CAC7E,KAAM,cAAe,KAAK,KAAK,QAAQ,SAAS,OAAQ,MAAM,cACxD,SAAW,GAAG,aAAa,aAAc,CAAE,SAAU,UAErD,WAAa,YAAY,UAE/B,MAAO,CACL,SAAU,MAAM,aAChB,UAAW,SAAA,mBAAmB,KAC9B,YATJ,QAAA,uBAAA",
  "names": []
}
