{
  "version": 3,
  "sources": ["cfn-reference.ts"],
  "sourcesContent": ["/* eslint-disable import/order */\nimport { Reference } from '../reference';\n\nconst CFN_REFERENCE_SYMBOL = Symbol.for('@aws-cdk/core.CfnReference');\n\n/**\n * An enum that allows controlling how will the created reference\n * be rendered in the resulting CloudFormation template.\n */\nexport enum ReferenceRendering {\n  /**\n   * Used for rendering a reference inside Fn::Sub expressions,\n   * which mean these must resolve to \"${Sth}\" instead of { Ref: \"Sth\" }.\n   */\n  FN_SUB,\n\n  /**\n   * Used for rendering Fn::GetAtt with its arguments in string form\n   * (as opposed to the more common arguments in array form, which we render by default).\n   */\n  GET_ATT_STRING,\n}\n\n/**\n * A Token that represents a CloudFormation reference to another resource\n *\n * If these references are used in a different stack from where they are\n * defined, appropriate CloudFormation `Export`s and `Fn::ImportValue`s will be\n * synthesized automatically instead of the regular CloudFormation references.\n *\n * Additionally, the dependency between the stacks will be recorded, and the toolkit\n * will make sure to deploy producing stack before the consuming stack.\n *\n * This magic happens in the prepare() phase, where consuming stacks will call\n * `consumeFromStack` on these Tokens and if they happen to be exported by a different\n * Stack, we'll register the dependency.\n */\nexport class CfnReference extends Reference {\n  /**\n   * Check whether this is actually a Reference\n   */\n  public static isCfnReference(x: IResolvable): x is CfnReference {\n    return CFN_REFERENCE_SYMBOL in x;\n  }\n\n  /**\n   * Return the CfnReference for the indicated target\n   *\n   * Will make sure that multiple invocations for the same target and intrinsic\n   * return the same CfnReference. Because CfnReferences accumulate state in\n   * the prepare() phase (for the purpose of cross-stack references), it's\n   * important that the state isn't lost if it's lazily created, like so:\n   *\n   *     Lazy.string({ produce: () => new CfnReference(...) })\n   *\n   */\n  public static for(target: CfnElement, attribute: string, refRender?: ReferenceRendering) {\n    return CfnReference.singletonReference(target, attribute, refRender, () => {\n      const cfnIntrinsic = refRender === ReferenceRendering.FN_SUB\n        ? ('${' + target.logicalId + (attribute === 'Ref' ? '' : `.${attribute}`) + '}')\n        : (attribute === 'Ref'\n          ? { Ref: target.logicalId }\n          : {\n            'Fn::GetAtt': refRender === ReferenceRendering.GET_ATT_STRING\n              ? `${target.logicalId}.${attribute}`\n              : [target.logicalId, attribute],\n          }\n        );\n      return new CfnReference(cfnIntrinsic, attribute, target);\n    });\n  }\n\n  /**\n   * Return a CfnReference that references a pseudo referencd\n   */\n  public static forPseudo(pseudoName: string, scope: Construct) {\n    return CfnReference.singletonReference(scope, `Pseudo:${pseudoName}`, undefined, () => {\n      const cfnIntrinsic = { Ref: pseudoName };\n      return new CfnReference(cfnIntrinsic, pseudoName, scope);\n    });\n  }\n\n  /**\n   * Static table where we keep singleton CfnReference instances\n   */\n  private static referenceTable = new Map<Construct, Map<string, CfnReference>>();\n\n  /**\n   * Get or create the table.\n   * Passing fnSub = true allows cloudformation-include to correctly handle Fn::Sub.\n   */\n  private static singletonReference(target: Construct, attribKey: string, refRender: ReferenceRendering | undefined, fresh: () => CfnReference) {\n    let attribs = CfnReference.referenceTable.get(target);\n    if (!attribs) {\n      attribs = new Map();\n      CfnReference.referenceTable.set(target, attribs);\n    }\n    let cacheKey = attribKey;\n    switch (refRender) {\n      case ReferenceRendering.FN_SUB:\n        cacheKey += 'Fn::Sub';\n        break;\n      case ReferenceRendering.GET_ATT_STRING:\n        cacheKey += 'Fn::GetAtt::String';\n        break;\n    }\n    let ref = attribs.get(cacheKey);\n    if (!ref) {\n      ref = fresh();\n      attribs.set(cacheKey, ref);\n    }\n    return ref;\n  }\n\n  /**\n   * The Tokens that should be returned for each consuming stack (as decided by the producing Stack)\n   */\n  private readonly replacementTokens: Map<Stack, IResolvable>;\n  private readonly targetStack: Stack;\n\n  protected constructor(value: any, displayName: string, target: IConstruct) {\n    // prepend scope path to display name\n    super(value, target, displayName);\n\n    this.replacementTokens = new Map<Stack, IResolvable>();\n    this.targetStack = Stack.of(target);\n\n    Object.defineProperty(this, CFN_REFERENCE_SYMBOL, { value: true });\n  }\n\n  public resolve(context: IResolveContext): any {\n    // If we have a special token for this consuming stack, resolve that. Otherwise resolve as if\n    // we are in the same stack.\n    const consumingStack = Stack.of(context.scope);\n    const token = this.replacementTokens.get(consumingStack);\n\n    // if (!token && this.isCrossStackReference(consumingStack) && !context.preparing) {\n    // eslint-disable-next-line max-len\n    //   throw new Error(`Cross-stack reference (${context.scope.node.path} -> ${this.target.node.path}) has not been assigned a value--call prepare() first`);\n    // }\n\n    if (token) {\n      return token.resolve(context);\n    } else {\n      return super.resolve(context);\n    }\n  }\n\n  public hasValueForStack(stack: Stack) {\n    if (stack === this.targetStack) {\n      return true;\n    }\n\n    return this.replacementTokens.has(stack);\n  }\n\n  public assignValueForStack(stack: Stack, value: IResolvable) {\n    if (stack === this.targetStack) {\n      throw new Error('cannot assign a value for the same stack');\n    }\n\n    if (this.hasValueForStack(stack)) {\n      throw new Error('Cannot assign a reference value twice to the same stack. Use hasValueForStack to check first');\n    }\n\n    this.replacementTokens.set(stack, value);\n  }\n  /**\n   * Implementation of toString() that will use the display name\n   */\n  public toString(): string {\n    return Token.asString(this, {\n      displayHint: `${this.target.node.id}.${this.displayName}`,\n    });\n  }\n}\n\nimport { Construct, IConstruct } from 'constructs';\nimport { CfnElement } from '../cfn-element';\nimport { IResolvable, IResolveContext } from '../resolvable';\nimport { Stack } from '../stack';\nimport { Token } from '../token';\n"],
  "mappings": "2HACA,KAAA,aAAA,QAAA,gBAEM,qBAAuB,OAAO,IAAI,8BAMxC,GAAY,oBAAZ,AAAA,UAAY,oBAAkB,CAK5B,oBAAA,oBAAA,OAAA,GAAA,SAMA,oBAAA,oBAAA,eAAA,GAAA,mBAXU,mBAAA,QAAA,oBAAA,SAAA,mBAAkB,KA4B9B,0BAAkC,aAAA,SAAS,CAmFzC,YAAsB,MAAY,YAAqB,OAAkB,CAEvE,MAAM,MAAO,OAAQ,aAErB,KAAK,kBAAoB,GAAI,KAC7B,KAAK,YAAc,QAAA,MAAM,GAAG,QAE5B,OAAO,eAAe,KAAM,qBAAsB,CAAE,MAAO,WAtF/C,gBAAe,EAAc,CACzC,MAAO,wBAAwB,SAcnB,KAAI,OAAoB,UAAmB,UAA8B,CACrF,MAAO,cAAa,mBAAmB,OAAQ,UAAW,UAAW,IAAK,CACxE,KAAM,cAAe,YAAc,mBAAmB,OACjD,KAAO,OAAO,UAAa,aAAc,MAAQ,GAAK,IAAI,aAAe,IACzE,YAAc,MACb,CAAE,IAAK,OAAO,WACd,CACA,aAAc,YAAc,mBAAmB,eAC3C,GAAG,OAAO,aAAa,YACvB,CAAC,OAAO,UAAW,YAG7B,MAAO,IAAI,cAAa,aAAc,UAAW,gBAOvC,WAAU,WAAoB,MAAgB,CAC1D,MAAO,cAAa,mBAAmB,MAAO,UAAU,aAAc,OAAW,IAAK,CACpF,KAAM,cAAe,CAAE,IAAK,YAC5B,MAAO,IAAI,cAAa,aAAc,WAAY,eAavC,oBAAmB,OAAmB,UAAmB,UAA2C,MAAyB,CAC1I,GAAI,SAAU,aAAa,eAAe,IAAI,QAC9C,AAAK,SACH,SAAU,GAAI,KACd,aAAa,eAAe,IAAI,OAAQ,UAE1C,GAAI,UAAW,UACf,OAAQ,eACD,oBAAmB,OACtB,UAAY,UACZ,UACG,oBAAmB,eACtB,UAAY,qBACZ,MAEJ,GAAI,KAAM,QAAQ,IAAI,UACtB,MAAK,MACH,KAAM,QACN,QAAQ,IAAI,SAAU,MAEjB,IAmBF,QAAQ,QAAwB,CAGrC,KAAM,gBAAiB,QAAA,MAAM,GAAG,QAAQ,OAClC,MAAQ,KAAK,kBAAkB,IAAI,gBAOzC,MAAI,OACK,MAAM,QAAQ,SAEd,MAAM,QAAQ,SAIlB,iBAAiB,MAAY,CAClC,MAAI,SAAU,KAAK,YACV,GAGF,KAAK,kBAAkB,IAAI,OAG7B,oBAAoB,MAAc,MAAkB,CACzD,GAAI,QAAU,KAAK,YACjB,KAAM,IAAI,OAAM,4CAGlB,GAAI,KAAK,iBAAiB,OACxB,KAAM,IAAI,OAAM,gGAGlB,KAAK,kBAAkB,IAAI,MAAO,OAK7B,UAAQ,CACb,MAAO,SAAA,MAAM,SAAS,KAAM,CAC1B,YAAa,GAAG,KAAK,OAAO,KAAK,MAAM,KAAK,iBAvIlD,QAAA,aAAA,aAgDiB,aAAA,eAAiB,GAAI,KA+FtC,KAAA,SAAA,QAAA,YACA,QAAA,QAAA",
  "names": []
}
