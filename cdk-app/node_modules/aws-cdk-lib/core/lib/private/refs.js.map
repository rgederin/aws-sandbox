{
  "version": 3,
  "sources": ["refs.ts"],
  "sourcesContent": ["// ----------------------------------------------------\n// CROSS REFERENCES\n// ----------------------------------------------------\n\nimport { IConstruct } from 'constructs';\nimport { CfnElement } from '../cfn-element';\nimport { CfnOutput } from '../cfn-output';\nimport { CfnParameter } from '../cfn-parameter';\nimport { Names } from '../names';\nimport { Reference } from '../reference';\nimport { IResolvable } from '../resolvable';\nimport { Stack } from '../stack';\nimport { Token, Tokenization } from '../token';\nimport { CfnReference } from './cfn-reference';\nimport { Intrinsic } from './intrinsic';\nimport { findTokens } from './resolve';\n\n/**\n * This is called from the App level to resolve all references defined. Each\n * reference is resolved based on it's consumption context.\n */\nexport function resolveReferences(scope: IConstruct): void {\n  const edges = findAllReferences(scope);\n\n  for (const { source, value } of edges) {\n    const consumer = Stack.of(source);\n\n    // resolve the value in the context of the consumer\n    if (!value.hasValueForStack(consumer)) {\n      const resolved = resolveValue(consumer, value);\n      value.assignValueForStack(consumer, resolved);\n    }\n  }\n}\n\n/**\n * Resolves the value for `reference` in the context of `consumer`.\n */\nfunction resolveValue(consumer: Stack, reference: CfnReference): IResolvable {\n  const producer = Stack.of(reference.target);\n\n  // produce and consumer stacks are the same, we can just return the value itself.\n  if (producer === consumer) {\n    return reference;\n  }\n\n  // unsupported: stacks from different apps\n  if (producer.node.root !== consumer.node.root) {\n    throw new Error('Cannot reference across apps. Consuming and producing stacks must be defined within the same CDK app.');\n  }\n\n  // unsupported: stacks are not in the same environment\n  if (producer.environment !== consumer.environment) {\n    throw new Error(\n      `Stack \"${consumer.node.path}\" cannot consume a cross reference from stack \"${producer.node.path}\". ` +\n      'Cross stack references are only supported for stacks deployed to the same environment or between nested stacks and their parent stack');\n  }\n\n  // ----------------------------------------------------------------------\n  // consumer is nested in the producer (directly or indirectly)\n  // ----------------------------------------------------------------------\n\n  // if the consumer is nested within the producer (directly or indirectly),\n  // wire through a CloudFormation parameter and then resolve the reference with\n  // the parent stack as the consumer.\n  if (consumer.nestedStackParent && isNested(consumer, producer)) {\n    const parameterValue = resolveValue(consumer.nestedStackParent, reference);\n    return createNestedStackParameter(consumer, reference, parameterValue);\n  }\n\n  // ----------------------------------------------------------------------\n  // producer is a nested stack\n  // ----------------------------------------------------------------------\n\n  // if the producer is nested, always publish the value through a\n  // cloudformation output and resolve recursively with the Fn::GetAtt\n  // of the output in the parent stack.\n\n  // one might ask, if the consumer is not a parent of the producer,\n  // why not just use export/import? the reason is that we cannot\n  // generate an \"export name\" from a nested stack because the export\n  // name must contain the stack name to ensure uniqueness, and we\n  // don't know the stack name of a nested stack before we deploy it.\n  // therefore, we can only export from a top-level stack.\n  if (producer.nested) {\n    const outputValue = createNestedStackOutput(producer, reference);\n    return resolveValue(consumer, outputValue);\n  }\n\n  // ----------------------------------------------------------------------\n  // export/import\n  // ----------------------------------------------------------------------\n\n  // export the value through a cloudformation \"export name\" and use an\n  // Fn::ImportValue in the consumption site.\n\n  // add a dependency between the producer and the consumer. dependency logic\n  // will take care of applying the dependency at the right level (e.g. the\n  // top-level stacks).\n  consumer.addDependency(producer,\n    `${consumer.node.path} -> ${reference.target.node.path}.${reference.displayName}`);\n\n  return createImportValue(reference);\n}\n\n/**\n * Finds all the CloudFormation references in a construct tree.\n */\nfunction findAllReferences(root: IConstruct) {\n  const result = new Array<{ source: CfnElement, value: CfnReference }>();\n  for (const consumer of root.node.findAll()) {\n\n    // include only CfnElements (i.e. resources)\n    if (!CfnElement.isCfnElement(consumer)) {\n      continue;\n    }\n\n    try {\n      const tokens = findTokens(consumer, () => consumer._toCloudFormation());\n\n      // iterate over all the tokens (e.g. intrinsic functions, lazies, etc) that\n      // were found in the cloudformation representation of this resource.\n      for (const token of tokens) {\n\n        // include only CfnReferences (i.e. \"Ref\" and \"Fn::GetAtt\")\n        if (!CfnReference.isCfnReference(token)) {\n          continue;\n        }\n\n        result.push({\n          source: consumer,\n          value: token,\n        });\n      }\n    } catch (e) {\n      // Note: it might be that the properties of the CFN object aren't valid.\n      // This will usually be preventatively caught in a construct's validate()\n      // and turned into a nicely descriptive error, but we're running prepare()\n      // before validate(). Swallow errors that occur because the CFN layer\n      // doesn't validate completely.\n      //\n      // This does make the assumption that the error will not be rectified,\n      // but the error will be thrown later on anyway. If the error doesn't\n      // get thrown down the line, we may miss references.\n      if (e.type === 'CfnSynthesisError') {\n        continue;\n      }\n\n      throw e;\n    }\n  }\n\n  return result;\n}\n\n// ------------------------------------------------------------------------------------------------\n// export/import\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Imports a value from another stack by creating an \"Output\" with an \"ExportName\"\n * and returning an \"Fn::ImportValue\" token.\n */\nfunction createImportValue(reference: Reference): Intrinsic {\n  const exportingStack = Stack.of(reference.target);\n\n  const importExpr = exportingStack.exportValue(reference);\n\n  // I happen to know this returns a Fn.importValue() which implements Intrinsic.\n  return Tokenization.reverseCompleteString(importExpr) as Intrinsic;\n}\n\n// ------------------------------------------------------------------------------------------------\n// nested stacks\n// ------------------------------------------------------------------------------------------------\n\n/**\n * Adds a CloudFormation parameter to a nested stack and assigns it with the\n * value of the reference.\n */\nfunction createNestedStackParameter(nested: Stack, reference: CfnReference, value: IResolvable) {\n  const paramId = generateUniqueId(nested, reference, 'reference-to-');\n  let param = nested.node.tryFindChild(paramId) as CfnParameter;\n  if (!param) {\n    param = new CfnParameter(nested, paramId, { type: 'String' });\n\n    // Ugly little hack until we move NestedStack to this module.\n    if (!('setParameter' in nested)) {\n      throw new Error('assertion failed: nested stack should have a \"setParameter\" method');\n    }\n\n    (nested as any).setParameter(param.logicalId, Token.asString(value));\n  }\n\n  return param.value as CfnReference;\n}\n\n/**\n * Adds a CloudFormation output to a nested stack and returns an \"Fn::GetAtt\"\n * intrinsic that can be used to reference this output in the parent stack.\n */\nfunction createNestedStackOutput(producer: Stack, reference: Reference): CfnReference {\n  const outputId = generateUniqueId(producer, reference);\n  let output = producer.node.tryFindChild(outputId) as CfnOutput;\n  if (!output) {\n    output = new CfnOutput(producer, outputId, { value: Token.asString(reference) });\n  }\n\n  if (!producer.nestedStackResource) {\n    throw new Error('assertion failed');\n  }\n\n  return producer.nestedStackResource.getAtt(`Outputs.${output.logicalId}`) as CfnReference;\n}\n\n/**\n * Translate a Reference into a nested stack into a value in the parent stack\n *\n * Will create Outputs along the chain of Nested Stacks, and return the final `{ Fn::GetAtt }`.\n */\nexport function referenceNestedStackValueInParent(reference: Reference, targetStack: Stack) {\n  let currentStack = Stack.of(reference.target);\n  if (currentStack !== targetStack && !isNested(currentStack, targetStack)) {\n    throw new Error(`Referenced resource must be in stack '${targetStack.node.path}', got '${reference.target.node.path}'`);\n  }\n\n  while (currentStack !== targetStack) {\n    reference = createNestedStackOutput(Stack.of(reference.target), reference);\n    currentStack = Stack.of(reference.target);\n  }\n\n  return reference;\n}\n\n/**\n * @returns true if this stack is a direct or indirect parent of the nested\n * stack `nested`.\n *\n * If `child` is not a nested stack, always returns `false` because it can't\n * have a parent, dah.\n */\nfunction isNested(nested: Stack, parent: Stack): boolean {\n  // if the parent is a direct parent\n  if (nested.nestedStackParent === parent) {\n    return true;\n  }\n\n  // we reached a top-level (non-nested) stack without finding the parent\n  if (!nested.nestedStackParent) {\n    return false;\n  }\n\n  // recurse with the child's direct parent\n  return isNested(nested.nestedStackParent, parent);\n}\n\n/**\n * Generates a unique id for a `Reference`\n * @param stack A stack used to resolve tokens\n * @param ref The reference\n * @param prefix Optional prefix for the id\n * @returns A unique id\n */\nfunction generateUniqueId(stack: Stack, ref: Reference, prefix = '') {\n  // we call \"resolve()\" to ensure that tokens do not creep in (for example, if the reference display name includes tokens)\n  return stack.resolve(`${prefix}${Names.nodeUniqueId(ref.target.node)}${ref.displayName}`);\n}\n"],
  "mappings": "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",
  "names": []
}
