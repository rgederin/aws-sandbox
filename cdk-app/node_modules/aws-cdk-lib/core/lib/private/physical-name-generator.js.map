{
  "version": 3,
  "sources": ["physical-name-generator.ts"],
  "sourcesContent": ["import * as crypto from 'crypto';\nimport { Node } from 'constructs';\nimport { Names } from '../names';\nimport { IResolvable, IResolveContext } from '../resolvable';\nimport { IResource } from '../resource';\nimport { Stack } from '../stack';\nimport { Token } from '../token';\nimport { TokenMap } from './token-map';\n\nexport function generatePhysicalName(resource: IResource): string {\n  const stack = Stack.of(resource);\n  const stackPart = new PrefixNamePart(stack.stackName, 25);\n  const idPart = new SuffixNamePart(Names.nodeUniqueId(resource.node), 24);\n\n  const region: string = stack.region;\n  if (Token.isUnresolved(region) || !region) {\n    throw new Error(`Cannot generate a physical name for ${Node.of(resource).path}, because the region is un-resolved or missing`);\n  }\n\n  const account: string = stack.account;\n  if (Token.isUnresolved(account) || !account) {\n    throw new Error(`Cannot generate a physical name for ${Node.of(resource).path}, because the account is un-resolved or missing`);\n  }\n\n  const parts = [stackPart, idPart]\n    .map(part => part.generate());\n\n  const hashLength = 12;\n  const sha256 = crypto.createHash('sha256')\n    .update(stackPart.bareStr)\n    .update(idPart.bareStr)\n    .update(region)\n    .update(account);\n  const hash = sha256.digest('hex').slice(0, hashLength);\n\n  const ret = [...parts, hash].join('');\n\n  return ret.toLowerCase();\n}\n\nabstract class NamePart {\n  public readonly bareStr: string;\n\n  constructor(bareStr: string) {\n    this.bareStr = bareStr;\n  }\n\n  public abstract generate(): string;\n}\n\nclass PrefixNamePart extends NamePart {\n  constructor(bareStr: string, private readonly prefixLength: number) {\n    super(bareStr);\n  }\n\n  public generate(): string {\n    return this.bareStr.slice(0, this.prefixLength);\n  }\n}\n\nclass SuffixNamePart extends NamePart {\n  constructor(str: string, private readonly suffixLength: number) {\n    super(str);\n  }\n\n  public generate(): string {\n    const strLen = this.bareStr.length;\n    const startIndex = Math.max(strLen - this.suffixLength, 0);\n    return this.bareStr.slice(startIndex, strLen);\n  }\n}\n\nconst GENERATE_IF_NEEDED_SYMBOL = Symbol.for('@aws-cdk/core.<private>.GenerateIfNeeded');\n\n/**\n * This marker token is used by PhysicalName.GENERATE_IF_NEEDED. When that token is passed to the\n * physicalName property of a Resource, it triggers different behavior in the Resource constructor\n * that will allow emission of a generated physical name (when the resource is used across\n * environments) or undefined (when the resource is not shared).\n *\n * This token throws an Error when it is resolved, as a way to prevent inadvertent mis-uses of it.\n */\nexport class GeneratedWhenNeededMarker implements IResolvable {\n  public readonly creationStack: string[] = [];\n\n  constructor() {\n    Object.defineProperty(this, GENERATE_IF_NEEDED_SYMBOL, { value: true });\n  }\n\n  public resolve(_ctx: IResolveContext): never {\n    throw new Error('Invalid physical name passed to CloudFormation. Use \"this.physicalName\" instead');\n  }\n\n  public toString(): string {\n    return 'PhysicalName.GENERATE_IF_NEEDED';\n  }\n}\n\n/**\n * Checks whether a stringified token resolves to a `GeneratedWhenNeededMarker`.\n */\nexport function isGeneratedWhenNeededMarker(val: string): boolean {\n  const token = TokenMap.instance().lookupString(val);\n  return !!token && GENERATE_IF_NEEDED_SYMBOL in token;\n}\n"],
  "mappings": "8KAAA,KAAA,QAAA,QAAA,UACA,aAAA,QAAA,cACA,QAAA,QAAA,YAGA,QAAA,QAAA,YACA,QAAA,QAAA,YACA,YAAA,QAAA,eAEA,8BAAqC,SAAmB,CACtD,KAAM,OAAQ,QAAA,MAAM,GAAG,UACjB,UAAY,GAAI,gBAAe,MAAM,UAAW,IAChD,OAAS,GAAI,gBAAe,QAAA,MAAM,aAAa,SAAS,MAAO,IAE/D,OAAiB,MAAM,OAC7B,GAAI,QAAA,MAAM,aAAa,SAAW,CAAC,OACjC,KAAM,IAAI,OAAM,uCAAuC,aAAA,KAAK,GAAG,UAAU,sDAG3E,KAAM,SAAkB,MAAM,QAC9B,GAAI,QAAA,MAAM,aAAa,UAAY,CAAC,QAClC,KAAM,IAAI,OAAM,uCAAuC,aAAA,KAAK,GAAG,UAAU,uDAG3E,KAAM,OAAQ,CAAC,UAAW,QACvB,IAAI,MAAQ,KAAK,YAEd,WAAa,GAMb,KAAO,AALE,OAAO,WAAW,UAC9B,OAAO,UAAU,SACjB,OAAO,OAAO,SACd,OAAO,QACP,OAAO,SACU,OAAO,OAAO,MAAM,EAAG,YAI3C,MAAO,AAFK,CAAC,GAAG,MAAO,MAAM,KAAK,IAEvB,cA5Bb,QAAA,qBAAA,qBA+BA,cAAuB,CAGrB,YAAY,QAAe,CACzB,KAAK,QAAU,SAMnB,4BAA6B,SAAQ,CACnC,YAAY,QAAkC,aAAoB,CAChE,MAAM,SADsC,KAAA,aAAA,aAIvC,UAAQ,CACb,MAAO,MAAK,QAAQ,MAAM,EAAG,KAAK,eAItC,4BAA6B,SAAQ,CACnC,YAAY,IAA8B,aAAoB,CAC5D,MAAM,KADkC,KAAA,aAAA,aAInC,UAAQ,CACb,KAAM,QAAS,KAAK,QAAQ,OACtB,WAAa,KAAK,IAAI,OAAS,KAAK,aAAc,GACxD,MAAO,MAAK,QAAQ,MAAM,WAAY,SAI1C,KAAM,2BAA4B,OAAO,IAAI,4CAU7C,+BAAsC,CAGpC,aAAA,CAFgB,KAAA,cAA0B,GAGxC,OAAO,eAAe,KAAM,0BAA2B,CAAE,MAAO,KAG3D,QAAQ,KAAqB,CAClC,KAAM,IAAI,OAAM,mFAGX,UAAQ,CACb,MAAO,mCAZX,QAAA,0BAAA,0BAmBA,qCAA4C,IAAW,CACrD,KAAM,OAAQ,YAAA,SAAS,WAAW,aAAa,KAC/C,MAAO,CAAC,CAAC,OAAS,4BAA6B,OAFjD,QAAA,4BAAA",
  "names": []
}
