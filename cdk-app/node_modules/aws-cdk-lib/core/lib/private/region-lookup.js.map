{
  "version": 3,
  "sources": ["region-lookup.ts"],
  "sourcesContent": ["import * as cxapi from '../../../cx-api';\nimport { RegionInfo } from '../../../region-info';\nimport { CfnMapping } from '../cfn-mapping';\nimport { Aws } from '../cfn-pseudo';\nimport { Stack } from '../stack';\n\n/**\n * Make sure a CfnMapping exists in the given stack with the lookup values for the given fact\n *\n * Add to an existing CfnMapping if possible.\n */\nexport function deployTimeLookup(stack: Stack, factName: string, lookupMap: Record<string, string>, defaultValue?: string) {\n  // If there are no lookups, just return the default\n  if (Object.values(lookupMap).length === 0) {\n    if (defaultValue === undefined) {\n      throw new Error(`region-info: don't have any information for ${factName}. Use 'Fact.register' to provide values, or add partitions to the '${cxapi.TARGET_PARTITIONS}' context value.`);\n    }\n    return defaultValue;\n  }\n\n  // If the tokenized representation of all values is the same, we can just\n  // return the value directly and don't need to produce an actual map.\n  const pattern = findValuePattern(lookupMap);\n  if (pattern !== undefined) {\n    return pattern;\n  }\n\n  // Derive map name and lookup key from the factName, splitting on ':' if it exists\n  const [factClass, factParam] = factName.includes(':')\n    ? factName.split(':')\n    : [factName, 'value'] as const;\n\n  const mapId = `${ucfirst(factClass)}Map`;\n  const factKey = factParam.replace(/[^a-zA-Z0-9]/g, 'x');\n\n  let mapping = stack.node.tryFindChild(mapId) as CfnMapping | undefined;\n  if (!mapping) {\n    mapping = new CfnMapping(stack, mapId);\n  }\n  for (const [region, value] of Object.entries(lookupMap)) {\n    mapping.setValue(region, factKey, value);\n  }\n  return mapping.findInMap(Aws.REGION, factKey);\n}\n\nfunction ucfirst(x: string) {\n  return `${x.substr(0, 1).toUpperCase()}${x.substr(1)}`;\n}\n\n/**\n * Try to detect if all values in the map follow the same pattern\n *\n * Do this by replacing region and URLSuffix values in the found strings\n * with their token variant. If at the end all strings have the same format,\n * we can simplify to just the single value.\n *\n * This wouldn't have been necessary if the region-info library had encoded the\n * pattern information instead of the literal values... but let's do it here now.\n */\nfunction findValuePattern(regionMap: Record<string, string>): string | undefined {\n  const simplified: Record<string, string> = { ...regionMap };\n\n  // If they all contain URL_SUFFIX, substitute it, but only if the value is different\n  // among some values in the list (we don't want to tokenize unnecessarily, i.e. we don't\n  // want to replace `amazonaws.com` with URL_SUFFIX if it's not necessary)\n  const urlSuffixes = Object.keys(simplified).map(urlSuffix);\n  if (!allSame(urlSuffixes) && Object.entries(simplified).every(([region, value]) => value.includes(urlSuffix(region)))) {\n    for (const region in simplified) {\n      simplified[region] = replaceAll(simplified[region], urlSuffix(region), Aws.URL_SUFFIX);\n    }\n  }\n\n  // If they all contain REGION, substitute it (no need to do the \"is everything different\"\n  // check, this is true by design for these values)\n  if (Object.entries(simplified).every(([region, value]) => value.includes(region))) {\n    for (const region in simplified) {\n      simplified[region] = replaceAll(simplified[region], region, Aws.REGION);\n    }\n  }\n\n  // If the values are now all the same, return the singleton value\n  const values = Object.values(simplified);\n  if (allSame(values)) {\n    return values[0];\n  }\n\n  // Otherwise we failed\n  return undefined;\n}\n\nfunction allSame(xs: string[]) {\n  return xs.every((x) => x === xs[0]);\n}\n\nfunction urlSuffix(region: string) {\n  return RegionInfo.get(region)?.domainSuffix ?? 'amazonaws.com';\n}\n\nfunction replaceAll(x: string, pat: string, replacement: string) {\n  return x.split(pat).join(replacement);\n}\n\n"],
  "mappings": "oGAAA,KAAA,OAAA,QAAA,mBACA,cAAA,QAAA,wBACA,cAAA,QAAA,kBACA,aAAA,QAAA,iBAQA,0BAAiC,MAAc,SAAkB,UAAmC,aAAqB,CAEvH,GAAI,OAAO,OAAO,WAAW,SAAW,EAAG,CACzC,GAAI,eAAiB,OACnB,KAAM,IAAI,OAAM,+CAA+C,8EAA8E,MAAM,qCAErJ,MAAO,cAKT,KAAM,SAAU,iBAAiB,WACjC,GAAI,UAAY,OACd,MAAO,SAIT,KAAM,CAAC,UAAW,WAAa,SAAS,SAAS,KAC7C,SAAS,MAAM,KACf,CAAC,SAAU,SAET,MAAQ,GAAG,QAAQ,gBACnB,QAAU,UAAU,QAAQ,gBAAiB,KAEnD,GAAI,SAAU,MAAM,KAAK,aAAa,OACtC,AAAK,SACH,SAAU,GAAI,eAAA,WAAW,MAAO,QAElC,SAAW,CAAC,OAAQ,QAAU,QAAO,QAAQ,WAC3C,QAAQ,SAAS,OAAQ,QAAS,OAEpC,MAAO,SAAQ,UAAU,aAAA,IAAI,OAAQ,SA/BvC,QAAA,iBAAA,iBAkCA,iBAAiB,EAAS,CACxB,MAAO,GAAG,EAAE,OAAO,EAAG,GAAG,gBAAgB,EAAE,OAAO,KAapD,0BAA0B,UAAiC,CACzD,KAAM,YAAqC,IAAK,WAK1C,YAAc,OAAO,KAAK,YAAY,IAAI,WAChD,GAAI,CAAC,QAAQ,cAAgB,OAAO,QAAQ,YAAY,MAAM,CAAC,CAAC,OAAQ,SAAW,MAAM,SAAS,UAAU,UAC1G,SAAW,UAAU,YACnB,WAAW,QAAU,WAAW,WAAW,QAAS,UAAU,QAAS,aAAA,IAAI,YAM/E,GAAI,OAAO,QAAQ,YAAY,MAAM,CAAC,CAAC,OAAQ,SAAW,MAAM,SAAS,SACvE,SAAW,UAAU,YACnB,WAAW,QAAU,WAAW,WAAW,QAAS,OAAQ,aAAA,IAAI,QAKpE,KAAM,QAAS,OAAO,OAAO,YAC7B,GAAI,QAAQ,QACV,MAAO,QAAO,GAOlB,iBAAiB,GAAY,CAC3B,MAAO,IAAG,MAAM,AAAC,GAAM,IAAM,GAAG,IAGlC,mBAAmB,OAAc,WAC/B,MAAA,IAAA,IAAO,cAAA,WAAW,IAAI,WAAO,MAAA,KAAA,OAAA,OAAA,GAAE,gBAAY,MAAA,KAAA,OAAA,GAAI,gBAGjD,oBAAoB,EAAW,IAAa,YAAmB,CAC7D,MAAO,GAAE,MAAM,KAAK,KAAK",
  "names": []
}
