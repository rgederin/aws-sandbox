{
  "version": 3,
  "sources": ["asset-staging.ts"],
  "sourcesContent": ["import * as crypto from 'crypto';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as cxapi from '../../cx-api';\nimport { Construct } from 'constructs';\nimport * as fs from 'fs-extra';\nimport * as minimatch from 'minimatch';\nimport { AssetHashType, AssetOptions, FileAssetPackaging } from './assets';\nimport { BundlingOptions, BundlingOutput } from './bundling';\nimport { FileSystem, FingerprintOptions } from './fs';\nimport { Names } from './names';\nimport { Cache } from './private/cache';\nimport { Stack } from './stack';\nimport { Stage } from './stage';\n\nconst ARCHIVE_EXTENSIONS = ['.zip', '.jar'];\n\n/**\n * A previously staged asset\n */\ninterface StagedAsset {\n  /**\n   * The path where we wrote this asset previously\n   */\n  readonly stagedPath: string;\n\n  /**\n   * The hash we used previously\n   */\n  readonly assetHash: string;\n\n  /**\n   * The packaging of the asset\n   */\n  readonly packaging: FileAssetPackaging,\n\n  /**\n   * Whether this asset is an archive\n   */\n  readonly isArchive: boolean;\n}\n\n/**\n * Initialization properties for `AssetStaging`.\n */\nexport interface AssetStagingProps extends FingerprintOptions, AssetOptions {\n  /**\n   * The source file or directory to copy from.\n   */\n  readonly sourcePath: string;\n}\n\n/**\n * Stages a file or directory from a location on the file system into a staging\n * directory.\n *\n * This is controlled by the context key 'aws:cdk:asset-staging' and enabled\n * by the CLI by default in order to ensure that when the CDK app exists, all\n * assets are available for deployment. Otherwise, if an app references assets\n * in temporary locations, those will not be available when it exists (see\n * https://github.com/aws/aws-cdk/issues/1716).\n *\n * The `stagedPath` property is a stringified token that represents the location\n * of the file or directory after staging. It will be resolved only during the\n * \"prepare\" stage and may be either the original path or the staged path\n * depending on the context setting.\n *\n * The file/directory are staged based on their content hash (fingerprint). This\n * means that only if content was changed, copy will happen.\n */\nexport class AssetStaging extends Construct {\n  /**\n   * The directory inside the bundling container into which the asset sources will be mounted.\n   */\n  public static readonly BUNDLING_INPUT_DIR = '/asset-input';\n\n  /**\n   * The directory inside the bundling container into which the bundled output should be written.\n   */\n  public static readonly BUNDLING_OUTPUT_DIR = '/asset-output';\n\n  /**\n   * Clears the asset hash cache\n   */\n  public static clearAssetHashCache() {\n    this.assetCache.clear();\n  }\n\n  /**\n   * Cache of asset hashes based on asset configuration to avoid repeated file\n   * system and bundling operations.\n   */\n  private static assetCache = new Cache<StagedAsset>();\n\n  /**\n   * Absolute path to the asset data.\n   *\n   * If asset staging is disabled, this will just be the source path or\n   * a temporary directory used for bundling.\n   *\n   * If asset staging is enabled it will be the staged path.\n   *\n   * IMPORTANT: If you are going to call `addFileAsset()`, use\n   * `relativeStagedPath()` instead.\n   *\n   * @deprecated - Use `absoluteStagedPath` instead.\n   */\n  public readonly stagedPath: string;\n\n  /**\n   * Absolute path to the asset data.\n   *\n   * If asset staging is disabled, this will just be the source path or\n   * a temporary directory used for bundling.\n   *\n   * If asset staging is enabled it will be the staged path.\n   *\n   * IMPORTANT: If you are going to call `addFileAsset()`, use\n   * `relativeStagedPath()` instead.\n   */\n  public readonly absoluteStagedPath: string;\n\n  /**\n   * The absolute path of the asset as it was referenced by the user.\n   */\n  public readonly sourcePath: string;\n\n  /**\n   * A cryptographic hash of the asset.\n   */\n  public readonly assetHash: string;\n\n  /**\n   * How this asset should be packaged.\n   */\n  public readonly packaging: FileAssetPackaging;\n\n  /**\n   * Whether this asset is an archive (zip or jar).\n   */\n  public readonly isArchive: boolean;\n\n  private readonly fingerprintOptions: FingerprintOptions;\n\n  private readonly hashType: AssetHashType;\n  private readonly assetOutdir: string;\n\n  /**\n   * A custom source fingerprint given by the user\n   *\n   * Will not be used literally, always hashed later on.\n   */\n  private customSourceFingerprint?: string;\n\n  private readonly cacheKey: string;\n\n  private readonly sourceStats: fs.Stats;\n\n  constructor(scope: Construct, id: string, props: AssetStagingProps) {\n    super(scope, id);\n\n    this.sourcePath = path.resolve(props.sourcePath);\n    this.fingerprintOptions = props;\n\n    if (!fs.existsSync(this.sourcePath)) {\n      throw new Error(`Cannot find asset at ${this.sourcePath}`);\n    }\n\n    this.sourceStats = fs.statSync(this.sourcePath);\n\n    const outdir = Stage.of(this)?.assetOutdir;\n    if (!outdir) {\n      throw new Error('unable to determine cloud assembly asset output directory. Assets must be defined indirectly within a \"Stage\" or an \"App\" scope');\n    }\n    this.assetOutdir = outdir;\n\n    // Determine the hash type based on the props as props.assetHashType is\n    // optional from a caller perspective.\n    this.customSourceFingerprint = props.assetHash;\n    this.hashType = determineHashType(props.assetHashType, this.customSourceFingerprint);\n\n    // Decide what we're going to do, without actually doing it yet\n    let stageThisAsset: () => StagedAsset;\n    let skip = false;\n    if (props.bundling) {\n      // Check if we actually have to bundle for this stack\n      const bundlingStacks: string[] = this.node.tryGetContext(cxapi.BUNDLING_STACKS) ?? ['*'];\n      // bundlingStacks is of the form `Stage/Stack`, convert it to `Stage-Stack` before comparing to stack name\n      skip = !bundlingStacks.find(pattern => minimatch(Stack.of(this).stackName, pattern.replace('/', '-')));\n      const bundling = props.bundling;\n      stageThisAsset = () => this.stageByBundling(bundling, skip);\n    } else {\n      stageThisAsset = () => this.stageByCopying();\n    }\n\n    // Calculate a cache key from the props. This way we can check if we already\n    // staged this asset and reuse the result (e.g. the same asset with the same\n    // configuration is used in multiple stacks). In this case we can completely\n    // skip file system and bundling operations.\n    //\n    // The output directory and whether this asset is skipped or not should also be\n    // part of the cache key to make sure we don't accidentally return the wrong\n    // staged asset from the cache.\n    this.cacheKey = calculateCacheKey({\n      outdir: this.assetOutdir,\n      sourcePath: path.resolve(props.sourcePath),\n      bundling: props.bundling,\n      assetHashType: this.hashType,\n      customFingerprint: this.customSourceFingerprint,\n      extraHash: props.extraHash,\n      exclude: props.exclude,\n      ignoreMode: props.ignoreMode,\n      skip,\n    });\n\n    const staged = AssetStaging.assetCache.obtain(this.cacheKey, stageThisAsset);\n    this.stagedPath = staged.stagedPath;\n    this.absoluteStagedPath = staged.stagedPath;\n    this.assetHash = staged.assetHash;\n    this.packaging = staged.packaging;\n    this.isArchive = staged.isArchive;\n  }\n\n  /**\n   * A cryptographic hash of the asset.\n   *\n   * @deprecated see `assetHash`.\n   */\n  public get sourceHash(): string {\n    return this.assetHash;\n  }\n\n  /**\n   * Return the path to the staged asset, relative to the Cloud Assembly (manifest) directory of the given stack\n   *\n   * Only returns a relative path if the asset was staged, returns an absolute path if\n   * it was not staged.\n   *\n   * A bundled asset might end up in the outDir and still not count as\n   * \"staged\"; if asset staging is disabled we're technically expected to\n   * reference source directories, but we don't have a source directory for the\n   * bundled outputs (as the bundle output is written to a temporary\n   * directory). Nevertheless, we will still return an absolute path.\n   *\n   * A non-obvious directory layout may look like this:\n   *\n   * ```\n   *   CLOUD ASSEMBLY ROOT\n   *     +-- asset.12345abcdef/\n   *     +-- assembly-Stage\n   *           +-- MyStack.template.json\n   *           +-- MyStack.assets.json <- will contain { \"path\": \"../asset.12345abcdef\" }\n   * ```\n   */\n  public relativeStagedPath(stack: Stack) {\n    const asmManifestDir = Stage.of(stack)?.outdir;\n    if (!asmManifestDir) { return this.stagedPath; }\n\n    const isOutsideAssetDir = path.relative(this.assetOutdir, this.stagedPath).startsWith('..');\n    if (isOutsideAssetDir || this.stagingDisabled) {\n      return this.stagedPath;\n    }\n\n    return path.relative(asmManifestDir, this.stagedPath);\n  }\n\n  /**\n   * Stage the source to the target by copying\n   *\n   * Optionally skip if staging is disabled, in which case we pretend we did something but we don't really.\n   */\n  private stageByCopying(): StagedAsset {\n    const assetHash = this.calculateHash(this.hashType);\n    const stagedPath = this.stagingDisabled\n      ? this.sourcePath\n      : path.resolve(this.assetOutdir, renderAssetFilename(assetHash, path.extname(this.sourcePath)));\n\n    if (!this.sourceStats.isDirectory() && !this.sourceStats.isFile()) {\n      throw new Error(`Asset ${this.sourcePath} is expected to be either a directory or a regular file`);\n    }\n\n    this.stageAsset(this.sourcePath, stagedPath, 'copy');\n\n    return {\n      assetHash,\n      stagedPath,\n      packaging: this.sourceStats.isDirectory() ? FileAssetPackaging.ZIP_DIRECTORY : FileAssetPackaging.FILE,\n      isArchive: this.sourceStats.isDirectory() || ARCHIVE_EXTENSIONS.includes(path.extname(this.sourcePath).toLowerCase()),\n    };\n  }\n\n  /**\n   * Stage the source to the target by bundling\n   *\n   * Optionally skip, in which case we pretend we did something but we don't really.\n   */\n  private stageByBundling(bundling: BundlingOptions, skip: boolean): StagedAsset {\n    if (!this.sourceStats.isDirectory()) {\n      throw new Error(`Asset ${this.sourcePath} is expected to be a directory when bundling`);\n    }\n\n    if (skip) {\n      // We should have bundled, but didn't to save time. Still pretend to have a hash.\n      // If the asset uses OUTPUT or BUNDLE, we use a CUSTOM hash to avoid fingerprinting\n      // a potentially very large source directory. Other hash types are kept the same.\n      let hashType = this.hashType;\n      if (hashType === AssetHashType.OUTPUT || hashType === AssetHashType.BUNDLE) {\n        this.customSourceFingerprint = Names.uniqueId(this);\n        hashType = AssetHashType.CUSTOM;\n      }\n      return {\n        assetHash: this.calculateHash(hashType, bundling),\n        stagedPath: this.sourcePath,\n        packaging: FileAssetPackaging.ZIP_DIRECTORY,\n        isArchive: true,\n      };\n    }\n\n    // Try to calculate assetHash beforehand (if we can)\n    let assetHash = this.hashType === AssetHashType.SOURCE || this.hashType === AssetHashType.CUSTOM\n      ? this.calculateHash(this.hashType, bundling)\n      : undefined;\n\n    const bundleDir = this.determineBundleDir(this.assetOutdir, assetHash);\n    this.bundle(bundling, bundleDir);\n\n    // Check bundling output content and determine if we will need to archive\n    const bundlingOutputType = bundling.outputType ?? BundlingOutput.AUTO_DISCOVER;\n    const bundledAsset = determineBundledAsset(bundleDir, bundlingOutputType);\n\n    // Calculate assetHash afterwards if we still must\n    assetHash = assetHash ?? this.calculateHash(this.hashType, bundling, bundledAsset.path);\n    const stagedPath = path.resolve(this.assetOutdir, renderAssetFilename(assetHash, bundledAsset.extension));\n\n    this.stageAsset(bundledAsset.path, stagedPath, 'move');\n\n    // If bundling produced a single archive file we \"touch\" this file in the bundling\n    // directory after it has been moved to the staging directory. This way if bundling\n    // is skipped because the bundling directory already exists we can still determine\n    // the correct packaging type.\n    if (bundledAsset.packaging === FileAssetPackaging.FILE) {\n      fs.closeSync(fs.openSync(bundledAsset.path, 'w'));\n    }\n\n    return {\n      assetHash,\n      stagedPath,\n      packaging: bundledAsset.packaging,\n      isArchive: true, // bundling always produces an archive\n    };\n  }\n\n  /**\n   * Whether staging has been disabled\n   */\n  private get stagingDisabled() {\n    return !!this.node.tryGetContext(cxapi.DISABLE_ASSET_STAGING_CONTEXT);\n  }\n\n  /**\n   * Copies or moves the files from sourcePath to targetPath.\n   *\n   * Moving implies the source directory is temporary and can be trashed.\n   *\n   * Will not do anything if source and target are the same.\n   */\n  private stageAsset(sourcePath: string, targetPath: string, style: 'move' | 'copy') {\n    // Is the work already done?\n    const isAlreadyStaged = fs.existsSync(targetPath);\n    if (isAlreadyStaged) {\n      if (style === 'move' && sourcePath !== targetPath) {\n        fs.removeSync(sourcePath);\n      }\n      return;\n    }\n\n    // Moving can be done quickly\n    if (style == 'move') {\n      fs.renameSync(sourcePath, targetPath);\n      return;\n    }\n\n    // Copy file/directory to staging directory\n    if (this.sourceStats.isFile()) {\n      fs.copyFileSync(sourcePath, targetPath);\n    } else if (this.sourceStats.isDirectory()) {\n      fs.mkdirSync(targetPath);\n      FileSystem.copyDirectory(sourcePath, targetPath, this.fingerprintOptions);\n    } else {\n      throw new Error(`Unknown file type: ${sourcePath}`);\n    }\n  }\n\n  /**\n   * Determine the directory where we're going to write the bundling output\n   *\n   * This is the target directory where we're going to write the staged output\n   * files if we can (if the hash is fully known), or a temporary directory\n   * otherwise.\n   */\n  private determineBundleDir(outdir: string, sourceHash?: string) {\n    if (sourceHash) {\n      return path.resolve(outdir, renderAssetFilename(sourceHash));\n    }\n\n    // When the asset hash isn't known in advance, bundler outputs to an\n    // intermediate directory named after the asset's cache key\n    return path.resolve(outdir, `bundling-temp-${this.cacheKey}`);\n  }\n\n  /**\n   * Bundles an asset to the given directory\n   *\n   * If the given directory already exists, assume that everything's already\n   * in order and don't do anything.\n   *\n   * @param options Bundling options\n   * @param bundleDir Where to create the bundle directory\n   * @returns The fully resolved bundle output directory.\n   */\n  private bundle(options: BundlingOptions, bundleDir: string) {\n    if (fs.existsSync(bundleDir)) { return; }\n\n    fs.ensureDirSync(bundleDir);\n    // Chmod the bundleDir to full access.\n    fs.chmodSync(bundleDir, 0o777);\n\n    // Always mount input and output dir\n    const volumes = [\n      {\n        hostPath: this.sourcePath,\n        containerPath: AssetStaging.BUNDLING_INPUT_DIR,\n      },\n      {\n        hostPath: bundleDir,\n        containerPath: AssetStaging.BUNDLING_OUTPUT_DIR,\n      },\n      ...options.volumes ?? [],\n    ];\n\n    let localBundling: boolean | undefined;\n    try {\n      process.stderr.write(`Bundling asset ${this.node.path}...\\n`);\n\n      localBundling = options.local?.tryBundle(bundleDir, options);\n      if (!localBundling) {\n        let user: string;\n        if (options.user) {\n          user = options.user;\n        } else { // Default to current user\n          const userInfo = os.userInfo();\n          user = userInfo.uid !== -1 // uid is -1 on Windows\n            ? `${userInfo.uid}:${userInfo.gid}`\n            : '1000:1000';\n        }\n\n        options.image.run({\n          command: options.command,\n          user,\n          volumes,\n          environment: options.environment,\n          workingDirectory: options.workingDirectory ?? AssetStaging.BUNDLING_INPUT_DIR,\n          securityOpt: options.securityOpt ?? '',\n        });\n      }\n    } catch (err) {\n      // When bundling fails, keep the bundle output for diagnosability, but\n      // rename it out of the way so that the next run doesn't assume it has a\n      // valid bundleDir.\n      const bundleErrorDir = bundleDir + '-error';\n      if (fs.existsSync(bundleErrorDir)) {\n        // Remove the last bundleErrorDir.\n        fs.removeSync(bundleErrorDir);\n      }\n\n      fs.renameSync(bundleDir, bundleErrorDir);\n      throw new Error(`Failed to bundle asset ${this.node.path}, bundle output is located at ${bundleErrorDir}: ${err}`);\n    }\n\n    if (FileSystem.isEmpty(bundleDir)) {\n      const outputDir = localBundling ? bundleDir : AssetStaging.BUNDLING_OUTPUT_DIR;\n      throw new Error(`Bundling did not produce any output. Check that content is written to ${outputDir}.`);\n    }\n  }\n\n  private calculateHash(hashType: AssetHashType, bundling?: BundlingOptions, outputDir?: string): string {\n    // When bundling a CUSTOM or SOURCE asset hash type, we want the hash to include\n    // the bundling configuration. We handle CUSTOM and bundled SOURCE hash types\n    // as a special case to preserve existing user asset hashes in all other cases.\n    if (hashType == AssetHashType.CUSTOM || (hashType == AssetHashType.SOURCE && bundling)) {\n      const hash = crypto.createHash('sha256');\n\n      // if asset hash is provided by user, use it, otherwise fingerprint the source.\n      hash.update(this.customSourceFingerprint ?? FileSystem.fingerprint(this.sourcePath, this.fingerprintOptions));\n\n      // If we're bundling an asset, include the bundling configuration in the hash\n      if (bundling) {\n        hash.update(JSON.stringify(bundling));\n      }\n\n      return hash.digest('hex');\n    }\n\n    switch (hashType) {\n      case AssetHashType.SOURCE:\n        return FileSystem.fingerprint(this.sourcePath, this.fingerprintOptions);\n      case AssetHashType.BUNDLE:\n      case AssetHashType.OUTPUT:\n        if (!outputDir) {\n          throw new Error(`Cannot use \\`${hashType}\\` hash type when \\`bundling\\` is not specified.`);\n        }\n        return FileSystem.fingerprint(outputDir, this.fingerprintOptions);\n      default:\n        throw new Error('Unknown asset hash type.');\n    }\n  }\n}\n\nfunction renderAssetFilename(assetHash: string, extension = '') {\n  return `asset.${assetHash}${extension}`;\n}\n\n/**\n * Determines the hash type from user-given prop values.\n *\n * @param assetHashType Asset hash type construct prop\n * @param customSourceFingerprint Asset hash seed given in the construct props\n */\nfunction determineHashType(assetHashType?: AssetHashType, customSourceFingerprint?: string) {\n  const hashType = customSourceFingerprint\n    ? (assetHashType ?? AssetHashType.CUSTOM)\n    : (assetHashType ?? AssetHashType.SOURCE);\n\n  if (customSourceFingerprint && hashType !== AssetHashType.CUSTOM) {\n    throw new Error(`Cannot specify \\`${assetHashType}\\` for \\`assetHashType\\` when \\`assetHash\\` is specified. Use \\`CUSTOM\\` or leave \\`undefined\\`.`);\n  }\n  if (hashType === AssetHashType.CUSTOM && !customSourceFingerprint) {\n    throw new Error('`assetHash` must be specified when `assetHashType` is set to `AssetHashType.CUSTOM`.');\n  }\n\n  return hashType;\n}\n\n/**\n * Calculates a cache key from the props. Normalize by sorting keys.\n */\nfunction calculateCacheKey<A extends object>(props: A): string {\n  return crypto.createHash('sha256')\n    .update(JSON.stringify(sortObject(props)))\n    .digest('hex');\n}\n\n/**\n * Recursively sort object keys\n */\nfunction sortObject(object: { [key: string]: any }): { [key: string]: any } {\n  if (typeof object !== 'object' || object instanceof Array) {\n    return object;\n  }\n  const ret: { [key: string]: any } = {};\n  for (const key of Object.keys(object).sort()) {\n    ret[key] = sortObject(object[key]);\n  }\n  return ret;\n}\n\n/**\n * Returns the single archive file of a directory or undefined\n */\nfunction singleArchiveFile(directory: string): string | undefined {\n  if (!fs.existsSync(directory)) {\n    throw new Error(`Directory ${directory} does not exist.`);\n  }\n\n  if (!fs.statSync(directory).isDirectory()) {\n    throw new Error(`${directory} is not a directory.`);\n  }\n\n  const content = fs.readdirSync(directory);\n  if (content.length === 1) {\n    const file = path.join(directory, content[0]);\n    const extension = path.extname(content[0]).toLowerCase();\n    if (fs.statSync(file).isFile() && ARCHIVE_EXTENSIONS.includes(extension)) {\n      return file;\n    }\n  }\n\n  return undefined;\n}\n\ninterface BundledAsset {\n  path: string,\n  packaging: FileAssetPackaging,\n  extension?: string\n}\n\n/**\n * Returns the bundled asset to use based on the content of the bundle directory\n * and the type of output.\n */\nfunction determineBundledAsset(bundleDir: string, outputType: BundlingOutput): BundledAsset {\n  const archiveFile = singleArchiveFile(bundleDir);\n\n  // auto-discover means that if there is an archive file, we take it as the\n  // bundle, otherwise, we will archive here.\n  if (outputType === BundlingOutput.AUTO_DISCOVER) {\n    outputType = archiveFile ? BundlingOutput.ARCHIVED : BundlingOutput.NOT_ARCHIVED;\n  }\n\n  switch (outputType) {\n    case BundlingOutput.NOT_ARCHIVED:\n      return { path: bundleDir, packaging: FileAssetPackaging.ZIP_DIRECTORY };\n    case BundlingOutput.ARCHIVED:\n      if (!archiveFile) {\n        throw new Error('Bundling output directory is expected to include only a single .zip or .jar file when `output` is set to `ARCHIVED`');\n      }\n      return { path: archiveFile, packaging: FileAssetPackaging.FILE, extension: path.extname(archiveFile) };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
