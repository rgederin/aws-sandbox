{
  "version": 3,
  "sources": ["arn.ts"],
  "sourcesContent": ["import { Fn } from './cfn-fn';\nimport { Stack } from './stack';\nimport { Token } from './token';\nimport { filterUndefined } from './util';\n\n/**\n * An enum representing the various ARN formats that different services use.\n */\nexport enum ArnFormat {\n  /**\n   * This represents a format where there is no 'resourceName' part.\n   * This format is used for S3 resources,\n   * like 'arn:aws:s3:::bucket'.\n   * Everything after the last colon is considered the 'resource',\n   * even if it contains slashes,\n   * like in 'arn:aws:s3:::bucket/object.zip'.\n   */\n  NO_RESOURCE_NAME = 'arn:aws:service:region:account:resource',\n\n  /**\n   * This represents a format where the 'resource' and 'resourceName'\n   * parts are separated with a colon.\n   * Like in: 'arn:aws:service:region:account:resource:resourceName'.\n   * Everything after the last colon is considered the 'resourceName',\n   * even if it contains slashes,\n   * like in 'arn:aws:apigateway:region:account:resource:/test/mydemoresource/*'.\n   */\n  COLON_RESOURCE_NAME = 'arn:aws:service:region:account:resource:resourceName',\n\n  /**\n   * This represents a format where the 'resource' and 'resourceName'\n   * parts are separated with a slash.\n   * Like in: 'arn:aws:service:region:account:resource/resourceName'.\n   * Everything after the separating slash is considered the 'resourceName',\n   * even if it contains colons,\n   * like in 'arn:aws:cognito-sync:region:account:identitypool/us-east-1:1a1a1a1a-ffff-1111-9999-12345678:bla'.\n   */\n  SLASH_RESOURCE_NAME = 'arn:aws:service:region:account:resource/resourceName',\n\n  /**\n   * This represents a format where the 'resource' and 'resourceName'\n   * parts are seperated with a slash,\n   * but there is also an additional slash after the colon separating 'account' from 'resource'.\n   * Like in: 'arn:aws:service:region:account:/resource/resourceName'.\n   * Note that the leading slash is _not_ included in the parsed 'resource' part.\n   */\n  SLASH_RESOURCE_SLASH_RESOURCE_NAME = 'arn:aws:service:region:account:/resource/resourceName',\n}\n\nexport interface ArnComponents {\n  /**\n   * The partition that the resource is in. For standard AWS regions, the\n   * partition is aws. If you have resources in other partitions, the\n   * partition is aws-partitionname. For example, the partition for resources\n   * in the China (Beijing) region is aws-cn.\n   *\n   * @default The AWS partition the stack is deployed to.\n   */\n  readonly partition?: string;\n\n  /**\n   * The service namespace that identifies the AWS product (for example,\n   * 's3', 'iam', 'codepipline').\n   */\n  readonly service: string;\n\n  /**\n   * The region the resource resides in. Note that the ARNs for some resources\n   * do not require a region, so this component might be omitted.\n   *\n   * @default The region the stack is deployed to.\n   */\n  readonly region?: string;\n\n  /**\n   * The ID of the AWS account that owns the resource, without the hyphens.\n   * For example, 123456789012. Note that the ARNs for some resources don't\n   * require an account number, so this component might be omitted.\n   *\n   * @default The account the stack is deployed to.\n   */\n  readonly account?: string;\n\n  /**\n   * Resource type (e.g. \"table\", \"autoScalingGroup\", \"certificate\").\n   * For some resource types, e.g. S3 buckets, this field defines the bucket name.\n   */\n  readonly resource: string;\n\n  /**\n   * Separator between resource type and the resource.\n   *\n   * Can be either '/', ':' or an empty string. Will only be used if resourceName is defined.\n   * @default '/'\n   *\n   * @deprecated use arnFormat instead\n   */\n  readonly sep?: string;\n\n  /**\n   * Resource name or path within the resource (i.e. S3 bucket object key) or\n   * a wildcard such as ``\"*\"``. This is service-dependent.\n   */\n  readonly resourceName?: string;\n\n  /**\n   * The specific ARN format to use for this ARN value.\n   *\n   * @default - uses value of `sep` as the separator for formatting,\n   *   `ArnFormat.SLASH_RESOURCE_NAME` if that property was also not provided\n   */\n  readonly arnFormat?: ArnFormat;\n}\n\nexport class Arn {\n  /**\n   * Creates an ARN from components.\n   *\n   * If `partition`, `region` or `account` are not specified, the stack's\n   * partition, region and account will be used.\n   *\n   * If any component is the empty string, an empty string will be inserted\n   * into the generated ARN at the location that component corresponds to.\n   *\n   * The ARN will be formatted as follows:\n   *\n   *   arn:{partition}:{service}:{region}:{account}:{resource}{sep}{resource-name}\n   *\n   * The required ARN pieces that are omitted will be taken from the stack that\n   * the 'scope' is attached to. If all ARN pieces are supplied, the supplied scope\n   * can be 'undefined'.\n   */\n  public static format(components: ArnComponents, stack?: Stack): string {\n    const partition = components.partition ?? stack?.partition;\n    const region = components.region ?? stack?.region;\n    const account = components.account ?? stack?.account;\n\n    // Catch both 'null' and 'undefined'\n    if (partition == null || region == null || account == null) {\n      throw new Error(`Arn.format: partition (${partition}), region (${region}), and account (${account}) must all be passed if stack is not passed.`);\n    }\n\n    const sep = components.sep ?? (components.arnFormat === ArnFormat.COLON_RESOURCE_NAME ? ':' : '/');\n\n    const values = [\n      'arn', ':', partition, ':', components.service, ':', region, ':', account, ':',\n      ...(components.arnFormat === ArnFormat.SLASH_RESOURCE_SLASH_RESOURCE_NAME ? ['/'] : []),\n      components.resource,\n    ];\n\n    if (sep !== '/' && sep !== ':' && sep !== '') {\n      throw new Error('resourcePathSep may only be \":\", \"/\" or an empty string');\n    }\n\n    if (components.resourceName != null) {\n      values.push(sep);\n      values.push(components.resourceName);\n    }\n\n    return values.join('');\n  }\n\n  /**\n   * Given an ARN, parses it and returns components.\n   *\n   * IF THE ARN IS A CONCRETE STRING...\n   *\n   * ...it will be parsed and validated. The separator (`sep`) will be set to '/'\n   * if the 6th component includes a '/', in which case, `resource` will be set\n   * to the value before the '/' and `resourceName` will be the rest. In case\n   * there is no '/', `resource` will be set to the 6th components and\n   * `resourceName` will be set to the rest of the string.\n   *\n   * IF THE ARN IS A TOKEN...\n   *\n   * ...it cannot be validated, since we don't have the actual value yet at the\n   * time of this function call. You will have to supply `sepIfToken` and\n   * whether or not ARNs of the expected format usually have resource names\n   * in order to parse it properly. The resulting `ArnComponents` object will\n   * contain tokens for the subexpressions of the ARN, not string literals.\n   *\n   * If the resource name could possibly contain the separator char, the actual\n   * resource name cannot be properly parsed. This only occurs if the separator\n   * char is '/', and happens for example for S3 object ARNs, IAM Role ARNs,\n   * IAM OIDC Provider ARNs, etc. To properly extract the resource name from a\n   * Tokenized ARN, you must know the resource type and call\n   * `Arn.extractResourceName`.\n   *\n   * @param arn The ARN to parse\n   * @param sepIfToken The separator used to separate resource from resourceName\n   * @param hasName Whether there is a name component in the ARN at all. For\n   * example, SNS Topics ARNs have the 'resource' component contain the topic\n   * name, and no 'resourceName' component.\n   *\n   * @returns an ArnComponents object which allows access to the various\n   * components of the ARN.\n   *\n   * @returns an ArnComponents object which allows access to the various\n   *      components of the ARN.\n   *\n   * @deprecated use split instead\n   */\n  public static parse(arn: string, sepIfToken: string = '/', hasName: boolean = true): ArnComponents {\n    let arnFormat: ArnFormat;\n    if (!hasName) {\n      arnFormat = ArnFormat.NO_RESOURCE_NAME;\n    } else {\n      arnFormat = sepIfToken === '/' ? ArnFormat.SLASH_RESOURCE_NAME : ArnFormat.COLON_RESOURCE_NAME;\n    }\n    return this.split(arn, arnFormat);\n  }\n\n  /**\n   * Splits the provided ARN into its components.\n   * Works both if 'arn' is a string like 'arn:aws:s3:::bucket',\n   * and a Token representing a dynamic CloudFormation expression\n   * (in which case the returned components will also be dynamic CloudFormation expressions,\n   * encoded as Tokens).\n   *\n   * @param arn the ARN to split into its components\n   * @param arnFormat the expected format of 'arn' - depends on what format the service 'arn' represents uses\n   */\n  public static split(arn: string, arnFormat: ArnFormat): ArnComponents {\n    const components = parseArnShape(arn);\n    if (components === 'token') {\n      return parseTokenArn(arn, arnFormat);\n    }\n\n    const [, partition, service, region, account, resourceTypeOrName, ...rest] = components;\n\n    let resource: string;\n    let resourceName: string | undefined;\n    let sep: string | undefined;\n    let resourcePartStartIndex = 0;\n    let detectedArnFormat: ArnFormat;\n\n    let slashIndex = resourceTypeOrName.indexOf('/');\n    if (slashIndex === 0) {\n      // new-style ARNs are of the form 'arn:aws:s4:us-west-1:12345:/resource-type/resource-name'\n      slashIndex = resourceTypeOrName.indexOf('/', 1);\n      resourcePartStartIndex = 1;\n      detectedArnFormat = ArnFormat.SLASH_RESOURCE_SLASH_RESOURCE_NAME;\n    }\n    if (slashIndex !== -1) {\n      // the slash is only a separator if ArnFormat is not NO_RESOURCE_NAME\n      if (arnFormat === ArnFormat.NO_RESOURCE_NAME) {\n        sep = undefined;\n        slashIndex = -1;\n        detectedArnFormat = ArnFormat.NO_RESOURCE_NAME;\n      } else {\n        sep = '/';\n        detectedArnFormat = resourcePartStartIndex === 0\n          ? ArnFormat.SLASH_RESOURCE_NAME\n          // need to repeat this here, as otherwise the compiler thinks 'detectedArnFormat' is not initialized in all paths\n          : ArnFormat.SLASH_RESOURCE_SLASH_RESOURCE_NAME;\n      }\n    } else if (rest.length > 0) {\n      sep = ':';\n      slashIndex = -1;\n      detectedArnFormat = ArnFormat.COLON_RESOURCE_NAME;\n    } else {\n      sep = undefined;\n      detectedArnFormat = ArnFormat.NO_RESOURCE_NAME;\n    }\n\n    if (slashIndex !== -1) {\n      resource = resourceTypeOrName.substring(resourcePartStartIndex, slashIndex);\n      resourceName = resourceTypeOrName.substring(slashIndex + 1);\n    } else {\n      resource = resourceTypeOrName;\n    }\n\n    if (rest.length > 0) {\n      if (!resourceName) {\n        resourceName = '';\n      } else {\n        resourceName += ':';\n      }\n\n      resourceName += rest.join(':');\n    }\n\n    // \"|| undefined\" will cause empty strings to be treated as \"undefined\".\n    // Optional ARN attributes (e.g. region, account) should return as empty string\n    // if they are provided as such.\n    return filterUndefined({\n      service: service || undefined,\n      resource: resource || undefined,\n      partition: partition || undefined,\n      region,\n      account,\n      resourceName,\n      sep,\n      arnFormat: detectedArnFormat,\n    });\n  }\n\n  /**\n   * Extract the full resource name from an ARN\n   *\n   * Necessary for resource names (paths) that may contain the separator, like\n   * `arn:aws:iam::111111111111:role/path/to/role/name`.\n   *\n   * Only works if we statically know the expected `resourceType` beforehand, since we're going\n   * to use that to split the string on ':<resourceType>/' (and take the right-hand side).\n   *\n   * We can't extract the 'resourceType' from the ARN at hand, because CloudFormation Expressions\n   * only allow literals in the 'separator' argument to `{ Fn::Split }`, and so it can't be\n   * `{ Fn::Select: [5, { Fn::Split: [':', ARN] }}`.\n   *\n   * Only necessary for ARN formats for which the type-name separator is `/`.\n   */\n  public static extractResourceName(arn: string, resourceType: string): string {\n    const components = parseArnShape(arn);\n    if (components === 'token') {\n      return Fn.select(1, Fn.split(`:${resourceType}/`, arn));\n    }\n\n    // Apparently we could just parse this right away. Validate that we got the right\n    // resource type (to notify authors of incorrect assumptions right away).\n    const parsed = Arn.split(arn, ArnFormat.SLASH_RESOURCE_NAME);\n    if (!Token.isUnresolved(parsed.resource) && parsed.resource !== resourceType) {\n      throw new Error(`Expected resource type '${resourceType}' in ARN, got '${parsed.resource}' in '${arn}'`);\n    }\n    if (!parsed.resourceName) {\n      throw new Error(`Expected resource name in ARN, didn't find one: '${arn}'`);\n    }\n    return parsed.resourceName;\n  }\n\n  private constructor() { }\n}\n\n/**\n * Given a Token evaluating to ARN, parses it and returns components.\n *\n * The ARN cannot be validated, since we don't have the actual value yet\n * at the time of this function call. You will have to know the separator\n * and the type of ARN.\n *\n * The resulting `ArnComponents` object will contain tokens for the\n * subexpressions of the ARN, not string literals.\n *\n * WARNING: this function cannot properly parse the complete final\n * 'resourceName' part if it contains colons,\n * like 'arn:aws:cognito-sync:region:account:identitypool/us-east-1:1a1a1a1a-ffff-1111-9999-12345678:bla'.\n *\n * @param arnToken The input token that contains an ARN\n * @param arnFormat the expected format of 'arn' - depends on what format the service the ARN represents uses\n */\nfunction parseTokenArn(arnToken: string, arnFormat: ArnFormat): ArnComponents {\n  // ARN looks like:\n  // arn:partition:service:region:account:resource\n  // arn:partition:service:region:account:resource:resourceName\n  // arn:partition:service:region:account:resource/resourceName\n  // arn:partition:service:region:account:/resource/resourceName\n\n  const components = Fn.split(':', arnToken);\n\n  const partition = Fn.select(1, components).toString();\n  const service = Fn.select(2, components).toString();\n  const region = Fn.select(3, components).toString();\n  const account = Fn.select(4, components).toString();\n  let resource: string;\n  let resourceName: string | undefined;\n  let sep: string | undefined;\n\n  if (arnFormat === ArnFormat.NO_RESOURCE_NAME || arnFormat === ArnFormat.COLON_RESOURCE_NAME) {\n    // we know that the 'resource' part will always be the 6th segment in this case\n    resource = Fn.select(5, components);\n    if (arnFormat === ArnFormat.COLON_RESOURCE_NAME) {\n      resourceName = Fn.select(6, components);\n      sep = ':';\n    } else {\n      resourceName = undefined;\n      sep = undefined;\n    }\n  } else {\n    // we know that the 'resource' and 'resourceName' parts are separated by slash here,\n    // so we split the 6th segment from the colon-separated ones with a slash\n    const lastComponents = Fn.split('/', Fn.select(5, components));\n\n    if (arnFormat === ArnFormat.SLASH_RESOURCE_NAME) {\n      resource = Fn.select(0, lastComponents);\n      resourceName = Fn.select(1, lastComponents);\n    } else {\n      // arnFormat is ArnFormat.SLASH_RESOURCE_SLASH_RESOURCE_NAME,\n      // which means there's an extra slash there at the beginning that we need to skip\n      resource = Fn.select(1, lastComponents);\n      resourceName = Fn.select(2, lastComponents);\n    }\n    sep = '/';\n  }\n\n  return { partition, service, region, account, resource, resourceName, sep, arnFormat };\n}\n\n/**\n * Validate that a string is either unparseable or looks mostly like an ARN\n */\nfunction parseArnShape(arn: string): 'token' | string[] {\n  // assume anything that starts with 'arn:' is an ARN,\n  // so we can report better errors\n  const looksLikeArn = arn.startsWith('arn:');\n\n  if (!looksLikeArn) {\n    if (Token.isUnresolved(arn)) {\n      return 'token';\n    } else {\n      throw new Error(`ARNs must start with \"arn:\" and have at least 6 components: ${arn}`);\n    }\n  }\n\n  // If the ARN merely contains Tokens, but otherwise *looks* mostly like an ARN,\n  // it's a string of the form 'arn:${partition}:service:${region}:${account}:resource/xyz'.\n  // Parse fields out to the best of our ability.\n  // Tokens won't contain \":\", so this won't break them.\n  const components = arn.split(':');\n\n  const partition = components.length > 1 ? components[1] : undefined;\n  if (!partition) {\n    throw new Error('The `partition` component (2nd component) of an ARN is required: ' + arn);\n  }\n\n  const service = components.length > 2 ? components[2] : undefined;\n  if (!service) {\n    throw new Error('The `service` component (3rd component) of an ARN is required: ' + arn);\n  }\n\n  const resource = components.length > 5 ? components[5] : undefined;\n  if (!resource) {\n    throw new Error('The `resource` component (6th component) of an ARN is required: ' + arn);\n  }\n\n  // Region can be missing in global ARNs (such as used by IAM)\n\n  // Account can be missing in some ARN types (such as used for S3 buckets)\n\n  return components;\n}\n"],
  "mappings": "4NAAA,SAAA,QAAA,YAEA,QAAA,QAAA,WACA,OAAA,QAAA,UAKA,GAAY,WAAZ,AAAA,UAAY,WAAS,CASnB,WAAA,iBAAA,0CAUA,WAAA,oBAAA,uDAUA,WAAA,oBAAA,uDASA,WAAA,mCAAA,0DAtCU,UAAA,QAAA,WAAA,SAAA,UAAS,KA0GrB,SAAgB,CAwNd,aAAA,QAtMc,QAAO,WAA2B,MAAa,gIAC3D,KAAM,WAAS,IAAG,WAAW,aAAS,MAAA,KAAA,OAAA,GAAI,OAAK,KAAA,OAAL,MAAO,UAC3C,OAAM,IAAG,WAAW,UAAM,MAAA,KAAA,OAAA,GAAI,OAAK,KAAA,OAAL,MAAO,OACrC,QAAO,IAAG,WAAW,WAAO,MAAA,KAAA,OAAA,GAAI,OAAK,KAAA,OAAL,MAAO,QAG7C,GAAI,WAAa,MAAQ,QAAU,MAAQ,SAAW,KACpD,KAAM,IAAI,OAAM,0BAA0B,uBAAuB,yBAAyB,uDAG5F,KAAM,KAAG,IAAG,WAAW,OAAG,MAAA,KAAA,OAAA,GAAK,WAAW,YAAc,UAAU,oBAAsB,IAAM,IAExF,OAAS,CACb,MAAO,IAAK,UAAW,IAAK,WAAW,QAAS,IAAK,OAAQ,IAAK,QAAS,IAC3E,GAAI,WAAW,YAAc,UAAU,mCAAqC,CAAC,KAAO,GACpF,WAAW,UAGb,GAAI,MAAQ,KAAO,MAAQ,KAAO,MAAQ,GACxC,KAAM,IAAI,OAAM,2DAGlB,MAAI,YAAW,cAAgB,MAC7B,QAAO,KAAK,KACZ,OAAO,KAAK,WAAW,eAGlB,OAAO,KAAK,UA2CP,OAAM,IAAa,WAAqB,IAAK,QAAmB,GAAI,CAChF,GAAI,WACJ,MAAK,SAGH,UAAY,aAAe,IAAM,UAAU,oBAAsB,UAAU,oBAF3E,UAAY,UAAU,iBAIjB,KAAK,MAAM,IAAK,iBAaX,OAAM,IAAa,UAAoB,0DACnD,KAAM,YAAa,cAAc,KACjC,GAAI,aAAe,QACjB,MAAO,eAAc,IAAK,WAG5B,KAAM,CAAC,CAAE,UAAW,QAAS,OAAQ,QAAS,sBAAuB,MAAQ,WAE7E,GAAI,UACA,aACA,IACA,uBAAyB,EACzB,kBAEA,WAAa,mBAAmB,QAAQ,KAC5C,MAAI,cAAe,GAEjB,YAAa,mBAAmB,QAAQ,IAAK,GAC7C,uBAAyB,EACzB,kBAAoB,UAAU,oCAEhC,AAAI,aAAe,GAEjB,AAAI,YAAc,UAAU,iBAC1B,KAAM,OACN,WAAa,GACb,kBAAoB,UAAU,kBAE9B,KAAM,IACN,kBAAoB,yBAA2B,EAC3C,UAAU,oBAEV,UAAU,oCAEX,AAAI,KAAK,OAAS,EACvB,KAAM,IACN,WAAa,GACb,kBAAoB,UAAU,qBAE9B,KAAM,OACN,kBAAoB,UAAU,kBAGhC,AAAI,aAAe,GACjB,UAAW,mBAAmB,UAAU,uBAAwB,YAChE,aAAe,mBAAmB,UAAU,WAAa,IAEzD,SAAW,mBAGT,KAAK,OAAS,GAChB,CAAK,aAGH,cAAgB,IAFhB,aAAe,GAKjB,cAAgB,KAAK,KAAK,MAMrB,OAAA,gBAAgB,CACrB,QAAS,SAAW,OACpB,SAAU,UAAY,OACtB,UAAW,WAAa,OACxB,OACA,QACA,aACA,IACA,UAAW,0BAmBD,qBAAoB,IAAa,aAAoB,CAEjE,GAAI,AADe,cAAc,OACd,QACjB,MAAO,UAAA,GAAG,OAAO,EAAG,SAAA,GAAG,MAAM,IAAI,gBAAiB,MAKpD,KAAM,QAAS,IAAI,MAAM,IAAK,UAAU,qBACxC,GAAI,CAAC,QAAA,MAAM,aAAa,OAAO,WAAa,OAAO,WAAa,aAC9D,KAAM,IAAI,OAAM,2BAA2B,8BAA8B,OAAO,iBAAiB,QAEnG,GAAI,CAAC,OAAO,aACV,KAAM,IAAI,OAAM,oDAAoD,QAEtE,MAAO,QAAO,cArNlB,QAAA,IAAA,2EA4OA,uBAAuB,SAAkB,UAAoB,CAO3D,KAAM,YAAa,SAAA,GAAG,MAAM,IAAK,UAE3B,UAAY,SAAA,GAAG,OAAO,EAAG,YAAY,WACrC,QAAU,SAAA,GAAG,OAAO,EAAG,YAAY,WACnC,OAAS,SAAA,GAAG,OAAO,EAAG,YAAY,WAClC,QAAU,SAAA,GAAG,OAAO,EAAG,YAAY,WACzC,GAAI,UACA,aACA,IAEJ,GAAI,YAAc,UAAU,kBAAoB,YAAc,UAAU,oBAEtE,SAAW,SAAA,GAAG,OAAO,EAAG,YACxB,AAAI,YAAc,UAAU,oBAC1B,cAAe,SAAA,GAAG,OAAO,EAAG,YAC5B,IAAM,KAEN,cAAe,OACf,IAAM,YAEH,CAGL,KAAM,gBAAiB,SAAA,GAAG,MAAM,IAAK,SAAA,GAAG,OAAO,EAAG,aAElD,AAAI,YAAc,UAAU,oBAC1B,UAAW,SAAA,GAAG,OAAO,EAAG,gBACxB,aAAe,SAAA,GAAG,OAAO,EAAG,iBAI5B,UAAW,SAAA,GAAG,OAAO,EAAG,gBACxB,aAAe,SAAA,GAAG,OAAO,EAAG,iBAE9B,IAAM,IAGR,MAAO,CAAE,UAAW,QAAS,OAAQ,QAAS,SAAU,aAAc,IAAK,WAM7E,uBAAuB,IAAW,CAKhC,GAAI,CAFiB,IAAI,WAAW,QAEjB,CACjB,GAAI,QAAA,MAAM,aAAa,KACrB,MAAO,QAEP,KAAM,IAAI,OAAM,+DAA+D,OAQnF,KAAM,YAAa,IAAI,MAAM,KAG7B,GAAI,CADc,YAAW,OAAS,EAAI,WAAW,GAAK,QAExD,KAAM,IAAI,OAAM,oEAAsE,KAIxF,GAAI,CADY,YAAW,OAAS,EAAI,WAAW,GAAK,QAEtD,KAAM,IAAI,OAAM,kEAAoE,KAItF,GAAI,CADa,YAAW,OAAS,EAAI,WAAW,GAAK,QAEvD,KAAM,IAAI,OAAM,mEAAqE,KAOvF,MAAO",
  "names": []
}
