{
  "version": 3,
  "sources": ["util.ts"],
  "sourcesContent": ["import { Token, TokenComparison } from '../../core';\nimport { EventPattern } from './event-pattern';\n\n/**\n * Merge the `src` event pattern into the `dest` event pattern by adding all\n * values from `src` into the fields in `dest`.\n *\n * See `rule.addEventPattern` for details.\n */\nexport function mergeEventPattern(dest: any, src: any) {\n  dest = dest || { };\n\n  mergeObject(dest, src);\n\n  return dest;\n\n  function mergeObject(destObj: any, srcObj: any) {\n    if (typeof(srcObj) !== 'object') {\n      throw new Error(`Invalid event pattern '${JSON.stringify(srcObj)}', expecting an object or an array`);\n    }\n\n    for (const field of Object.keys(srcObj)) {\n\n      const srcValue = srcObj[field];\n      const destValue = destObj[field];\n\n      if (srcValue === undefined) { continue; }\n\n      if (typeof(srcValue) !== 'object') {\n        throw new Error(`Invalid event pattern field { ${field}: ${JSON.stringify(srcValue)} }. All fields must be arrays`);\n      }\n\n      // dest doesn't have this field\n      if (destObj[field] === undefined) {\n        destObj[field] = srcValue;\n        continue;\n      }\n\n      if (Array.isArray(srcValue) !== Array.isArray(destValue)) {\n        throw new Error(`Invalid event pattern field ${field}. ` +\n          `Type mismatch between existing pattern ${JSON.stringify(destValue)} and added pattern ${JSON.stringify(srcValue)}`);\n      }\n\n      // if this is an array, concat and deduplicate the values\n      if (Array.isArray(srcValue)) {\n        const result = [...destValue, ...srcValue];\n        const resultJson = result.map(i => JSON.stringify(i));\n        destObj[field] = result.filter((value, index) => resultJson.indexOf(JSON.stringify(value)) === index);\n        continue;\n      }\n\n      // otherwise, it's an object, so recurse\n      mergeObject(destObj[field], srcValue);\n    }\n  }\n}\n\n/**\n * Whether two string probably contain the same environment dimension (region or account)\n *\n * Used to compare either accounts or regions, and also returns true if both\n * are unresolved (in which case both are expted to be \"current region\" or \"current account\").\n * @internal\n */\nexport function sameEnvDimension(dim1: string, dim2: string) {\n  return [TokenComparison.SAME, TokenComparison.BOTH_UNRESOLVED].includes(Token.compareStrings(dim1, dim2));\n}\n\n/**\n * Transform an eventPattern object into a valid Event Rule Pattern\n * by changing detailType into detail-type when present.\n */\nexport function renderEventPattern(eventPattern: EventPattern): any {\n  if (Object.keys(eventPattern).length === 0) {\n    return undefined;\n  }\n\n  // rename 'detailType' to 'detail-type'\n  const out: any = {};\n  for (let key of Object.keys(eventPattern)) {\n    const value = (eventPattern as any)[key];\n    if (key === 'detailType') {\n      key = 'detail-type';\n    }\n    out[key] = value;\n  }\n\n  return out;\n}"],
  "mappings": "yJAAA,KAAA,QAAA,QAAA,cASA,2BAAkC,KAAW,IAAQ,CACnD,YAAO,MAAQ,GAEf,YAAY,KAAM,KAEX,KAEP,qBAAqB,QAAc,OAAW,CAC5C,GAAI,MAAO,SAAY,SACrB,KAAM,IAAI,OAAM,0BAA0B,KAAK,UAAU,6CAG3D,SAAW,SAAS,QAAO,KAAK,QAAS,CAEvC,KAAM,UAAW,OAAO,OAClB,UAAY,QAAQ,OAE1B,GAAI,WAAa,OAEjB,IAAI,MAAO,WAAc,SACvB,KAAM,IAAI,OAAM,iCAAiC,UAAU,KAAK,UAAU,0CAI5E,GAAI,QAAQ,SAAW,OAAW,CAChC,QAAQ,OAAS,SACjB,SAGF,GAAI,MAAM,QAAQ,YAAc,MAAM,QAAQ,WAC5C,KAAM,IAAI,OAAM,+BAA+B,iDACH,KAAK,UAAU,gCAAgC,KAAK,UAAU,aAI5G,GAAI,MAAM,QAAQ,UAAW,CAC3B,KAAM,QAAS,CAAC,GAAG,UAAW,GAAG,UAC3B,WAAa,OAAO,IAAI,GAAK,KAAK,UAAU,IAClD,QAAQ,OAAS,OAAO,OAAO,CAAC,MAAO,QAAU,WAAW,QAAQ,KAAK,UAAU,UAAY,OAC/F,SAIF,YAAY,QAAQ,OAAQ,aA3ClC,QAAA,kBAAA,kBAuDA,0BAAiC,KAAc,KAAY,CACzD,MAAO,CAAC,OAAA,gBAAgB,KAAM,OAAA,gBAAgB,iBAAiB,SAAS,OAAA,MAAM,eAAe,KAAM,OADrG,QAAA,iBAAA,iBAQA,4BAAmC,aAA0B,CAC3D,GAAI,OAAO,KAAK,cAAc,SAAW,EACvC,OAIF,KAAM,KAAW,GACjB,OAAS,OAAO,QAAO,KAAK,cAAe,CACzC,KAAM,OAAS,aAAqB,KACpC,AAAI,MAAQ,cACV,KAAM,eAER,IAAI,KAAO,MAGb,MAAO,KAfT,QAAA,mBAAA",
  "names": []
}
