{
  "version": 3,
  "sources": ["input.ts"],
  "sourcesContent": ["import {\n  captureStackTrace, DefaultTokenResolver, IResolvable,\n  IResolveContext, Lazy, Stack, StringConcat, Token, Tokenization,\n} from '../../core';\nimport { IRule } from './rule-ref';\n\n/**\n * The input to send to the event target\n */\nexport abstract class RuleTargetInput {\n  /**\n   * Pass text to the event target\n   *\n   * May contain strings returned by `EventField.from()` to substitute in parts of the\n   * matched event.\n   *\n   * The Rule Target input value will be a single string: the string you pass\n   * here.  Do not use this method to pass a complex value like a JSON object to\n   * a Rule Target.  Use `RuleTargetInput.fromObject()` instead.\n   */\n  public static fromText(text: string): RuleTargetInput {\n    return new FieldAwareEventInput(text, InputType.Text);\n  }\n\n  /**\n   * Pass text to the event target, splitting on newlines.\n   *\n   * This is only useful when passing to a target that does not\n   * take a single argument.\n   *\n   * May contain strings returned by `EventField.from()` to substitute in parts\n   * of the matched event.\n   */\n  public static fromMultilineText(text: string): RuleTargetInput {\n    return new FieldAwareEventInput(text, InputType.Multiline);\n  }\n\n  /**\n   * Pass a JSON object to the event target\n   *\n   * May contain strings returned by `EventField.from()` to substitute in parts of the\n   * matched event.\n   */\n  public static fromObject(obj: any): RuleTargetInput {\n    return new FieldAwareEventInput(obj, InputType.Object);\n  }\n\n  /**\n   * Take the event target input from a path in the event JSON\n   */\n  public static fromEventPath(path: string): RuleTargetInput {\n    return new LiteralEventInput({ inputPath: path });\n  }\n\n  protected constructor() {\n  }\n\n  /**\n   * Return the input properties for this input object\n   */\n  public abstract bind(rule: IRule): RuleTargetInputProperties;\n}\n\n/**\n * The input properties for an event target\n */\nexport interface RuleTargetInputProperties {\n  /**\n   * Literal input to the target service (must be valid JSON)\n   *\n   * @default - input for the event target. If the input contains a paths map\n   *   values wil be extracted from event and inserted into the `inputTemplate`.\n   */\n  readonly input?: string;\n\n  /**\n   * JsonPath to take input from the input event\n   *\n   * @default - None. The entire matched event is passed as input\n   */\n  readonly inputPath?: string;\n\n  /**\n   * Input template to insert paths map into\n   *\n   * @default - None.\n   */\n  readonly inputTemplate?: string;\n\n  /**\n   * Paths map to extract values from event and insert into `inputTemplate`\n   *\n   * @default - No values extracted from event.\n   */\n  readonly inputPathsMap?: { [key: string]: string };\n}\n\n/**\n * Event Input that is directly derived from the construct\n */\nclass LiteralEventInput extends RuleTargetInput {\n  constructor(private readonly props: RuleTargetInputProperties) {\n    super();\n  }\n\n  /**\n   * Return the input properties for this input object\n   */\n  public bind(_rule: IRule): RuleTargetInputProperties {\n    return this.props;\n  }\n}\n\n/**\n * Input object that can contain field replacements\n *\n * Evaluation is done in the bind() method because token resolution\n * requires access to the construct tree.\n *\n * Multiple tokens that use the same path will use the same substitution\n * key.\n *\n * One weird exception: if we're in object context, we MUST skip the quotes\n * around the placeholder. I assume this is so once a trivial string replace is\n * done later on by EventBridge, numbers are still numbers.\n *\n * So in string context:\n *\n *    \"this is a string with a <field>\"\n *\n * But in object context:\n *\n *    \"{ \\\"this is the\\\": <field> }\"\n *\n * To achieve the latter, we postprocess the JSON string to remove the surrounding\n * quotes by using a string replace.\n */\nclass FieldAwareEventInput extends RuleTargetInput {\n  constructor(private readonly input: any, private readonly inputType: InputType) {\n    super();\n  }\n\n  public bind(rule: IRule): RuleTargetInputProperties {\n    let fieldCounter = 0;\n    const pathToKey = new Map<string, string>();\n    const inputPathsMap: {[key: string]: string} = {};\n\n    function keyForField(f: EventField) {\n      const existing = pathToKey.get(f.path);\n      if (existing !== undefined) { return existing; }\n\n      fieldCounter += 1;\n      const key = f.displayHint || `f${fieldCounter}`;\n      pathToKey.set(f.path, key);\n      return key;\n    }\n\n    class EventFieldReplacer extends DefaultTokenResolver {\n      constructor() {\n        super(new StringConcat());\n      }\n\n      public resolveToken(t: Token, _context: IResolveContext) {\n        if (!isEventField(t)) { return Token.asString(t); }\n\n        const key = keyForField(t);\n        if (inputPathsMap[key] && inputPathsMap[key] !== t.path) {\n          throw new Error(`Single key '${key}' is used for two different JSON paths: '${t.path}' and '${inputPathsMap[key]}'`);\n        }\n        inputPathsMap[key] = t.path;\n\n        return `<${key}>`;\n      }\n    }\n\n    const stack = Stack.of(rule);\n\n    let resolved: string;\n    if (this.inputType === InputType.Multiline) {\n      // JSONify individual lines\n      resolved = Tokenization.resolve(this.input, {\n        scope: rule,\n        resolver: new EventFieldReplacer(),\n      });\n      resolved = resolved.split('\\n').map(stack.toJsonString).join('\\n');\n    } else {\n      resolved = stack.toJsonString(Tokenization.resolve(this.input, {\n        scope: rule,\n        resolver: new EventFieldReplacer(),\n      }));\n    }\n\n    const keys = Object.keys(inputPathsMap);\n\n    if (keys.length === 0) {\n      // Nothing special, just return 'input'\n      return { input: resolved };\n    }\n\n    return {\n      inputTemplate: this.unquoteKeyPlaceholders(resolved, keys),\n      inputPathsMap,\n    };\n  }\n\n  /**\n   * Removing surrounding quotes from any object placeholders\n   * when key is the lone value.\n   *\n   * Those have been put there by JSON.stringify(), but we need to\n   * remove them.\n   *\n   * Do not remove quotes when the key is part of a larger string.\n   *\n   * Valid: { \"data\": \"Some string with \\\"quotes\\\"<key>\" } // key will be string\n   * Valid: { \"data\": <key> } // Key could be number, bool, obj, or string\n   */\n  private unquoteKeyPlaceholders(sub: string, keys: string[]) {\n    if (this.inputType !== InputType.Object) { return sub; }\n\n    return Lazy.uncachedString({ produce: (ctx: IResolveContext) => Token.asString(deepUnquote(ctx.resolve(sub))) });\n\n    function deepUnquote(resolved: any): any {\n      if (Array.isArray(resolved)) {\n        return resolved.map(deepUnquote);\n      } else if (typeof(resolved) === 'object' && resolved !== null) {\n        for (const [key, value] of Object.entries(resolved)) {\n          resolved[key] = deepUnquote(value);\n        }\n        return resolved;\n      } else if (typeof(resolved) === 'string') {\n        return keys.reduce((r, key) => r.replace(new RegExp(`(?<!\\\\\\\\)\\\"\\<${key}\\>\\\"`, 'g'), `<${key}>`), resolved);\n      }\n      return resolved;\n    }\n  }\n}\n\n/**\n * Represents a field in the event pattern\n */\nexport class EventField implements IResolvable {\n  /**\n   * Extract the event ID from the event\n   */\n  public static get eventId(): string {\n    return this.fromPath('$.id');\n  }\n\n  /**\n   * Extract the detail type from the event\n   */\n  public static get detailType(): string {\n    return this.fromPath('$.detail-type');\n  }\n\n  /**\n   * Extract the source from the event\n   */\n  public static get source(): string {\n    return this.fromPath('$.source');\n  }\n\n  /**\n   * Extract the account from the event\n   */\n  public static get account(): string {\n    return this.fromPath('$.account');\n  }\n\n  /**\n   * Extract the time from the event\n   */\n  public static get time(): string {\n    return this.fromPath('$.time');\n  }\n\n  /**\n   * Extract the region from the event\n   */\n  public static get region(): string {\n    return this.fromPath('$.region');\n  }\n\n  /**\n   * Extract a custom JSON path from the event\n   */\n  public static fromPath(path: string): string {\n    return new EventField(path).toString();\n  }\n\n  /**\n   * Human readable display hint about the event pattern\n   */\n  public readonly displayHint: string;\n  public readonly creationStack: string[];\n\n  /**\n   *\n   * @param path the path to a field in the event pattern\n   */\n  private constructor(public readonly path: string) {\n    this.displayHint = this.path.replace(/^[^a-zA-Z0-9_-]+/, '').replace(/[^a-zA-Z0-9_-]/g, '-');\n    Object.defineProperty(this, EVENT_FIELD_SYMBOL, { value: true });\n    this.creationStack = captureStackTrace();\n  }\n\n  public resolve(_ctx: IResolveContext): any {\n    return this.path;\n  }\n\n  public toString() {\n    return Token.asString(this, { displayHint: this.displayHint });\n  }\n\n  /**\n   * Convert the path to the field in the event pattern to JSON\n   */\n  public toJSON() {\n    return `<path:${this.path}>`;\n  }\n}\n\nenum InputType {\n  Object,\n  Text,\n  Multiline,\n}\n\nfunction isEventField(x: any): x is EventField {\n  return EVENT_FIELD_SYMBOL in x;\n}\n\nconst EVENT_FIELD_SYMBOL = Symbol.for('@aws-cdk/aws-events.EventField');\n"],
  "mappings": "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",
  "names": []
}
