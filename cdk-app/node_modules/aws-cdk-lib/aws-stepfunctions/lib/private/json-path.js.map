{
  "version": 3,
  "sources": ["json-path.ts"],
  "sourcesContent": ["import { captureStackTrace, IResolvable, IResolveContext, Token, Tokenization } from '../../../core';\nimport { IntrinsicParser, IntrinsicExpression } from './intrinstics';\n\nconst JSON_PATH_TOKEN_SYMBOL = Symbol.for('@aws-cdk/aws-stepfunctions.JsonPathToken');\n\nexport class JsonPathToken implements IResolvable {\n  public static isJsonPathToken(x: IResolvable): x is JsonPathToken {\n    return (x as any)[JSON_PATH_TOKEN_SYMBOL] === true;\n  }\n\n  public readonly creationStack: string[];\n  public displayHint: string;\n\n  constructor(public readonly path: string) {\n    this.creationStack = captureStackTrace();\n    this.displayHint = path.replace(/^[^a-zA-Z]+/, '');\n    Object.defineProperty(this, JSON_PATH_TOKEN_SYMBOL, { value: true });\n  }\n\n  public resolve(_ctx: IResolveContext): any {\n    return this.path;\n  }\n\n  public toString() {\n    return Token.asString(this, { displayHint: this.displayHint });\n  }\n\n  public toJSON() {\n    return `<path:${this.path}>`;\n  }\n}\n\n/**\n * Deep render a JSON object to expand JSON path fields, updating the key to end in '.$'\n */\nexport function renderObject(obj: object | undefined): object | undefined {\n  return recurseObject(obj, {\n    handleString: renderString,\n    handleList: renderStringList,\n    handleNumber: renderNumber,\n    handleBoolean: renderBoolean,\n    handleResolvable: renderResolvable,\n  });\n}\n\n/**\n * Return all JSON paths that are used in the given structure\n */\nexport function findReferencedPaths(obj: object | undefined): Set<string> {\n  const found = new Set<string>();\n\n  recurseObject(obj, {\n    handleString(_key: string, x: string) {\n      for (const p of findPathsInIntrinsicFunctions(jsonPathString(x))) {\n        found.add(p);\n      }\n      return {};\n    },\n\n    handleList(_key: string, x: string[]) {\n      for (const p of findPathsInIntrinsicFunctions(jsonPathStringList(x))) {\n        found.add(p);\n      }\n      return {};\n    },\n\n    handleNumber(_key: string, x: number) {\n      for (const p of findPathsInIntrinsicFunctions(jsonPathNumber(x))) {\n        found.add(p);\n      }\n      return {};\n    },\n\n    handleBoolean(_key: string, _x: boolean) {\n      return {};\n    },\n\n    handleResolvable(_key: string, x: IResolvable) {\n      for (const p of findPathsInIntrinsicFunctions(jsonPathFromAny(x))) {\n        found.add(p);\n      }\n      return {};\n    },\n  });\n\n  return found;\n}\n\n/**\n * From an expression, return the list of JSON paths referenced in it\n */\nfunction findPathsInIntrinsicFunctions(expression?: string): string[] {\n  if (!expression) { return []; }\n\n  const ret = new Array<string>();\n\n  try {\n    const parsed = new IntrinsicParser(expression).parseTopLevelIntrinsic();\n    recurse(parsed);\n    return ret;\n  } catch (e) {\n    // Not sure that our parsing is 100% correct. We don't want to break anyone, so\n    // fall back to legacy behavior if we can't parse this string.\n    return [expression];\n  }\n\n  function recurse(p: IntrinsicExpression) {\n    switch (p.type) {\n      case 'path':\n        ret.push(p.path);\n        break;\n\n      case 'fncall':\n        for (const arg of p.arguments) {\n          recurse(arg);\n        }\n    }\n  }\n}\n\ninterface FieldHandlers {\n  handleString(key: string, x: string): {[key: string]: string};\n  handleList(key: string, x: string[]): {[key: string]: string[] | string };\n  handleNumber(key: string, x: number): {[key: string]: number | string};\n  handleBoolean(key: string, x: boolean): {[key: string]: boolean};\n  handleResolvable(key: string, x: IResolvable): {[key: string]: any};\n}\n\nexport function recurseObject(obj: object | undefined, handlers: FieldHandlers, visited: object[] = []): object | undefined {\n  // If the argument received is not actually an object (string, number, boolean, undefined, ...) or null\n  // just return it as is as there's nothing to be rendered. This should only happen in the original call to\n  // recurseObject as any recursive calls to it are checking for typeof value === 'object' && value !== null\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  // Avoiding infinite recursion\n  if (visited.includes(obj)) { return {}; }\n\n  // Marking current object as visited for the current recursion path\n  visited.push(obj);\n\n  const ret: any = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (typeof value === 'string') {\n      Object.assign(ret, handlers.handleString(key, value));\n    } else if (typeof value === 'number') {\n      Object.assign(ret, handlers.handleNumber(key, value));\n    } else if (Array.isArray(value)) {\n      Object.assign(ret, recurseArray(key, value, handlers, visited));\n    } else if (typeof value === 'boolean') {\n      Object.assign(ret, handlers.handleBoolean(key, value));\n    } else if (value === null || value === undefined) {\n      // Nothing\n    } else if (typeof value === 'object') {\n      if (Tokenization.isResolvable(value)) {\n        Object.assign(ret, handlers.handleResolvable(key, value));\n      } else {\n        ret[key] = recurseObject(value, handlers, visited);\n      }\n    }\n  }\n\n  // Removing from visited after leaving the current recursion path\n  // Allowing it to be visited again if it's not causing a recursion (circular reference)\n  visited.pop();\n\n  return ret;\n}\n\n/**\n * Render an array that may or may not contain a string list token\n */\nfunction recurseArray(key: string, arr: any[], handlers: FieldHandlers, visited: object[] = []): {[key: string]: any[] | string} {\n  if (isStringArray(arr)) {\n    const path = jsonPathStringList(arr);\n    if (path !== undefined) {\n      return handlers.handleList(key, arr);\n    }\n\n    // Fall through to correctly reject encoded strings inside an array.\n    // They cannot be represented because there is no key to append a '.$' to.\n  }\n\n  return {\n    [key]: arr.map(value => {\n      if ((typeof value === 'string' && jsonPathString(value) !== undefined)\n        || (typeof value === 'number' && jsonPathNumber(value) !== undefined)\n        || (isStringArray(value) && jsonPathStringList(value) !== undefined)) {\n        throw new Error('Cannot use JsonPath fields in an array, they must be used in objects');\n      }\n      if (typeof value === 'object' && value !== null) {\n        return recurseObject(value, handlers, visited);\n      }\n      return value;\n    }),\n  };\n}\n\nfunction isStringArray(x: any): x is string[] {\n  return Array.isArray(x) && x.every(el => typeof el === 'string');\n}\n\n/**\n * Render a parameter string\n *\n * If the string value starts with '$.', render it as a path string, otherwise as a direct string.\n */\nfunction renderString(key: string, value: string): {[key: string]: string} {\n  const path = jsonPathString(value);\n  if (path !== undefined) {\n    return { [key + '.$']: path };\n  } else {\n    return { [key]: value };\n  }\n}\n\n/**\n * Render a resolvable\n *\n * If we can extract a Path from it, render as a path string, otherwise as itself (will\n * be resolved later\n */\nfunction renderResolvable(key: string, value: IResolvable): {[key: string]: any} {\n  const path = jsonPathFromAny(value);\n  if (path !== undefined) {\n    return { [key + '.$']: path };\n  } else {\n    return { [key]: value };\n  }\n}\n\n/**\n * Render a parameter string list\n *\n * If the string value starts with '$.', render it as a path string, otherwise as a direct string.\n */\nfunction renderStringList(key: string, value: string[]): {[key: string]: string[] | string} {\n  const path = jsonPathStringList(value);\n  if (path !== undefined) {\n    return { [key + '.$']: path };\n  } else {\n    return { [key]: value };\n  }\n}\n\n/**\n * Render a parameter number\n *\n * If the string value starts with '$.', render it as a path string, otherwise as a direct string.\n */\nfunction renderNumber(key: string, value: number): {[key: string]: number | string} {\n  const path = jsonPathNumber(value);\n  if (path !== undefined) {\n    return { [key + '.$']: path };\n  } else {\n    return { [key]: value };\n  }\n}\n\n/**\n * Render a parameter boolean\n */\nfunction renderBoolean(key: string, value: boolean): {[key: string]: boolean} {\n  return { [key]: value };\n}\n\n/**\n * If the indicated string is an encoded JSON path, return the path\n *\n * Otherwise return undefined.\n */\nexport function jsonPathString(x: string): string | undefined {\n  const fragments = Tokenization.reverseString(x);\n  const jsonPathTokens = fragments.tokens.filter(JsonPathToken.isJsonPathToken);\n\n  if (jsonPathTokens.length > 0 && fragments.length > 1) {\n    throw new Error(`Field references must be the entire string, cannot concatenate them (found '${x}')`);\n  }\n  if (jsonPathTokens.length > 0) {\n    return jsonPathTokens[0].path;\n  }\n  return undefined;\n}\n\nexport function jsonPathFromAny(x: any) {\n  if (!x) { return undefined; }\n  if (typeof x === 'string') { return jsonPathString(x); }\n  return pathFromToken(Tokenization.reverse(x));\n}\n\n/**\n * If the indicated string list is an encoded JSON path, return the path\n *\n * Otherwise return undefined.\n */\nfunction jsonPathStringList(x: string[]): string | undefined {\n  return pathFromToken(Tokenization.reverseList(x));\n}\n\n/**\n * If the indicated number is an encoded JSON path, return the path\n *\n * Otherwise return undefined.\n */\nfunction jsonPathNumber(x: number): string | undefined {\n  return pathFromToken(Tokenization.reverseNumber(x));\n}\n\nfunction pathFromToken(token: IResolvable | undefined) {\n  return token && (JsonPathToken.isJsonPathToken(token) ? token.path : undefined);\n}\n\n/**\n * Render the string in a valid JSON Path expression.\n *\n * If the string is a Tokenized JSON path reference -- return the JSON path reference inside it.\n * Otherwise, single-quote it.\n *\n * Call this function whenever you're building compound JSONPath expressions, in\n * order to avoid having tokens-in-tokens-in-tokens which become very hard to parse.\n */\nexport function renderInExpression(x: string) {\n  const path = jsonPathString(x);\n  return path ?? singleQuotestring(x);\n}\n\nfunction singleQuotestring(x: string) {\n  const ret = new Array<string>();\n  ret.push(\"'\");\n  for (const c of x) {\n    if (c === \"'\") {\n      ret.push(\"\\\\'\");\n    } else if (c === '\\\\') {\n      ret.push('\\\\\\\\');\n    } else if (c === '\\n') {\n      ret.push('\\\\n');\n    } else {\n      ret.push(c);\n    }\n  }\n  ret.push(\"'\");\n  return ret.join('');\n}"],
  "mappings": "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",
  "names": []
}
