{
  "version": 3,
  "sources": ["intrinstics.ts"],
  "sourcesContent": ["export type IntrinsicExpression = StringLiteralExpression | PathExpression | FnCallExpression;\nexport type TopLevelIntrinsic = PathExpression | FnCallExpression;\n\nexport interface StringLiteralExpression {\n  readonly type: 'string-literal';\n  readonly literal: string;\n}\n\nexport interface PathExpression {\n  readonly type: 'path';\n  readonly path: string;\n}\n\nexport interface FnCallExpression {\n  readonly type: 'fncall';\n  readonly functionName: string;\n  readonly arguments: IntrinsicExpression[];\n}\n\n\n/**\n * LL(1) parser for StepFunctions intrinsics\n *\n * The parser implements a state machine over a cursor into an expression\n * string. The cusor gets moved, the character at the cursor gets inspected\n * and based on the character we accumulate some value and potentially move\n * to a different state.\n *\n * Literal strings are not allowed at the top level, but are allowed inside\n * function calls.\n */\nexport class IntrinsicParser {\n  private i: number = 0;\n\n  constructor(private readonly expression: string) {\n  }\n\n  public parseTopLevelIntrinsic(): TopLevelIntrinsic {\n    this.ws();\n\n    let ret;\n    if (this.char() === '$') {\n      ret = this.parsePath();\n    } else if (isAlphaNum(this.char())) {\n      ret = this.parseFnCall();\n    } else {\n      this.raiseError(\"expected '$' or a function call\");\n    }\n\n    this.ws();\n\n    if (!this.eof) {\n      this.raiseError('unexpected trailing characters');\n    }\n\n    return ret;\n  }\n\n  private parseIntrinsic(): IntrinsicExpression {\n    this.ws();\n\n    if (this.char() === '$') {\n      return this.parsePath();\n    }\n\n    if (isAlphaNum(this.char())) {\n      return this.parseFnCall();\n    }\n\n    if (this.char() === \"'\") {\n      return this.parseStringLiteral();\n    }\n\n    this.raiseError('expected $, function or single-quoted string');\n  }\n\n  /**\n   * Simplified path parsing\n   *\n   * JSON path can actually be quite complicated, but we don't need to validate\n   * it precisely. We just need to know how far it extends.\n   *\n   * Therefore, we only care about:\n   *\n   * - Starts with a $\n   * - Accept ., $ and alphanums\n   * - Accept single-quoted strings ('...')\n   * - Accept anything between matched square brackets ([...])\n   */\n  private parsePath(): PathExpression {\n    const pathString = new Array<string>();\n    if (this.char() !== '$') {\n      this.raiseError('expected \\'$\\'');\n    }\n    pathString.push(this.consume());\n\n    let done = false;\n    while (!done && !this.eof) {\n      switch (this.char()) {\n        case '.':\n        case '$':\n          pathString.push(this.consume());\n          break;\n        case \"'\":\n          const { quoted } = this.consumeQuotedString();\n          pathString.push(quoted);\n          break;\n\n        case '[':\n          pathString.push(this.consumeBracketedExpression(']'));\n          break;\n\n        default:\n          if (isAlphaNum(this.char())) {\n            pathString.push(this.consume());\n            break;\n          }\n\n          // Not alphanum, end of path expression\n          done = true;\n      }\n    }\n\n    return { type: 'path', path: pathString.join('') };\n  }\n\n  /**\n   * Parse a fncall\n   *\n   * Cursor should be on call identifier. Afterwards, cursor will be on closing\n   * quote.\n   */\n  private parseFnCall(): FnCallExpression {\n    const name = new Array<string>();\n    while (this.char() !== '(') {\n      name.push(this.consume());\n    }\n\n    this.next(); // Consume the '('\n    this.ws();\n\n    const args = [];\n    while (this.char() !== ')') {\n      args.push(this.parseIntrinsic());\n      this.ws();\n\n      if (this.char() === ',') {\n        this.next();\n        continue;\n      } else if (this.char() === ')') {\n        continue;\n      } else {\n        this.raiseError('expected , or )');\n      }\n    }\n    this.next(); // Consume ')'\n\n    return {\n      type: 'fncall',\n      arguments: args,\n      functionName: name.join(''),\n    };\n  }\n\n  /**\n   * Parse a string literal\n   *\n   * Cursor is expected to be on the first opening quote. Afterwards,\n   * cursor will be after the closing quote.\n   */\n  private parseStringLiteral(): StringLiteralExpression {\n    const { unquoted } = this.consumeQuotedString();\n    return { type: 'string-literal', literal: unquoted };\n  }\n\n  /**\n   * Parse a bracketed expression\n   *\n   * Cursor is expected to be on the opening brace. Afterwards,\n   * the cursor will be after the closing brace.\n   */\n  private consumeBracketedExpression(closingBrace: string): string {\n    const ret = new Array<string>();\n    ret.push(this.consume());\n    while (this.char() !== closingBrace) {\n      if (this.char() === '[') {\n        ret.push(this.consumeBracketedExpression(']'));\n      } else if (this.char() === '{') {\n        ret.push(this.consumeBracketedExpression('}'));\n      } else {\n        ret.push(this.consume());\n      }\n    }\n    ret.push(this.consume());\n    return ret.join('');\n  }\n\n  /**\n   * Parse a string literal\n   *\n   * Cursor is expected to be on the first opening quote. Afterwards,\n   * cursor will be after the closing quote.\n   */\n  private consumeQuotedString(): { readonly quoted: string; unquoted: string } {\n    const quoted = new Array<string>();\n    const unquoted = new Array<string>();\n\n    quoted.push(this.consume());\n    while (this.char() !== \"'\") {\n      if (this.char() === '\\\\') {\n        // Advance and add next character literally, whatever it is\n        quoted.push(this.consume());\n      }\n      quoted.push(this.char());\n      unquoted.push(this.char());\n      this.next();\n    }\n    quoted.push(this.consume());\n    return { quoted: quoted.join(''), unquoted: unquoted.join('') };\n  }\n\n  /**\n   * Consume whitespace if it exists\n   *\n   * Move the cursor to the next non-whitespace character.\n   */\n  private ws() {\n    while (!this.eof && [' ', '\\t', '\\n'].includes(this.char())) {\n      this.next();\n    }\n  }\n\n  private get eof() {\n    return this.i >= this.expression.length;\n  }\n\n  private char(): string {\n    if (this.eof) {\n      this.raiseError('unexpected end of string');\n    }\n\n    return this.expression[this.i];\n  }\n\n  private next() {\n    this.i++;\n  }\n\n  private consume() {\n    const ret = this.char();\n    this.next();\n    return ret;\n  }\n\n  private raiseError(message: string): never {\n    throw new Error(`Invalid JSONPath expression: ${message} at index ${this.i} in ${JSON.stringify(this.expression)}`);\n  }\n}\n\nfunction isAlphaNum(x: string) {\n  return x.match(/^[a-zA-Z0-9]$/);\n}\n"],
  "mappings": "mGA+BA,qBAA4B,CAG1B,YAA6B,WAAkB,CAAlB,KAAA,WAAA,WAFrB,KAAA,EAAY,EAKb,wBAAsB,CAC3B,KAAK,KAEL,GAAI,KACJ,MAAI,MAAK,SAAW,IAClB,IAAM,KAAK,YACN,AAAI,WAAW,KAAK,QACzB,IAAM,KAAK,cAEX,KAAK,WAAW,mCAGlB,KAAK,KAEA,KAAK,KACR,KAAK,WAAW,kCAGX,IAGD,gBAAc,CAGpB,GAFA,KAAK,KAED,KAAK,SAAW,IAClB,MAAO,MAAK,YAGd,GAAI,WAAW,KAAK,QAClB,MAAO,MAAK,cAGd,GAAI,KAAK,SAAW,IAClB,MAAO,MAAK,qBAGd,KAAK,WAAW,gDAgBV,WAAS,CACf,KAAM,YAAa,GAAI,OACvB,AAAI,KAAK,SAAW,KAClB,KAAK,WAAW,gBAElB,WAAW,KAAK,KAAK,WAErB,GAAI,MAAO,GACX,KAAO,CAAC,MAAQ,CAAC,KAAK,KACpB,OAAQ,KAAK,YACN,QACA,IACH,WAAW,KAAK,KAAK,WACrB,UACG,IACH,KAAM,CAAE,QAAW,KAAK,sBACxB,WAAW,KAAK,QAChB,UAEG,IACH,WAAW,KAAK,KAAK,2BAA2B,MAChD,cAGA,GAAI,WAAW,KAAK,QAAS,CAC3B,WAAW,KAAK,KAAK,WACrB,MAIF,KAAO,GAIb,MAAO,CAAE,KAAM,OAAQ,KAAM,WAAW,KAAK,KASvC,aAAW,CACjB,KAAM,MAAO,GAAI,OACjB,KAAO,KAAK,SAAW,KACrB,KAAK,KAAK,KAAK,WAGjB,KAAK,OACL,KAAK,KAEL,KAAM,MAAO,GACb,KAAO,KAAK,SAAW,KAIrB,GAHA,KAAK,KAAK,KAAK,kBACf,KAAK,KAED,KAAK,SAAW,IAAK,CACvB,KAAK,OACL,aACK,IAAI,KAAK,SAAW,IACzB,SAEA,KAAK,WAAW,mBAGpB,YAAK,OAEE,CACL,KAAM,SACN,UAAW,KACX,aAAc,KAAK,KAAK,KAUpB,oBAAkB,CACxB,KAAM,CAAE,UAAa,KAAK,sBAC1B,MAAO,CAAE,KAAM,iBAAkB,QAAS,UASpC,2BAA2B,aAAoB,CACrD,KAAM,KAAM,GAAI,OAEhB,IADA,IAAI,KAAK,KAAK,WACP,KAAK,SAAW,cACrB,AAAI,KAAK,SAAW,IAClB,IAAI,KAAK,KAAK,2BAA2B,MACpC,AAAI,KAAK,SAAW,IACzB,IAAI,KAAK,KAAK,2BAA2B,MAEzC,IAAI,KAAK,KAAK,WAGlB,WAAI,KAAK,KAAK,WACP,IAAI,KAAK,IASV,qBAAmB,CACzB,KAAM,QAAS,GAAI,OACb,SAAW,GAAI,OAGrB,IADA,OAAO,KAAK,KAAK,WACV,KAAK,SAAW,KACrB,AAAI,KAAK,SAAW,MAElB,OAAO,KAAK,KAAK,WAEnB,OAAO,KAAK,KAAK,QACjB,SAAS,KAAK,KAAK,QACnB,KAAK,OAEP,cAAO,KAAK,KAAK,WACV,CAAE,OAAQ,OAAO,KAAK,IAAK,SAAU,SAAS,KAAK,KAQpD,IAAE,CACR,KAAO,CAAC,KAAK,KAAO,CAAC,IAAK,IAAM;GAAM,SAAS,KAAK,SAClD,KAAK,UAIG,MAAG,CACb,MAAO,MAAK,GAAK,KAAK,WAAW,OAG3B,MAAI,CACV,MAAI,MAAK,KACP,KAAK,WAAW,4BAGX,KAAK,WAAW,KAAK,GAGtB,MAAI,CACV,KAAK,IAGC,SAAO,CACb,KAAM,KAAM,KAAK,OACjB,YAAK,OACE,IAGD,WAAW,QAAe,CAChC,KAAM,IAAI,OAAM,gCAAgC,oBAAoB,KAAK,QAAQ,KAAK,UAAU,KAAK,gBAhOzG,QAAA,gBAAA,gBAoOA,oBAAoB,EAAS,CAC3B,MAAO,GAAE,MAAM",
  "names": []
}
