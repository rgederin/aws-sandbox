{
  "version": 3,
  "sources": ["pipeline.ts"],
  "sourcesContent": ["import * as notifications from '../../aws-codestarnotifications';\nimport * as events from '../../aws-events';\nimport * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport * as s3 from '../../aws-s3';\nimport {\n  ArnFormat,\n  BootstraplessSynthesizer,\n  DefaultStackSynthesizer,\n  IStackSynthesizer,\n  Lazy,\n  Names,\n  PhysicalName,\n  RemovalPolicy,\n  Resource,\n  Stack,\n  Stage as CdkStage,\n  Token,\n} from '../../core';\nimport { Construct } from 'constructs';\nimport { ActionCategory, IAction, IPipeline, IStage, PipelineNotificationEvents, PipelineNotifyOnOptions } from './action';\nimport { CfnPipeline } from './codepipeline.generated';\nimport { CrossRegionSupportConstruct, CrossRegionSupportStack } from './private/cross-region-support-stack';\nimport { FullActionDescriptor } from './private/full-action-descriptor';\nimport { RichAction } from './private/rich-action';\nimport { Stage } from './private/stage';\nimport { validateName, validateNamespaceName, validateSourceAction } from './private/validation';\n\n/**\n * Allows you to control where to place a new Stage when it's added to the Pipeline.\n * Note that you can provide only one of the below properties -\n * specifying more than one will result in a validation error.\n *\n * @see #rightBefore\n * @see #justAfter\n */\nexport interface StagePlacement {\n  /**\n   * Inserts the new Stage as a parent of the given Stage\n   * (changing its current parent Stage, if it had one).\n   */\n  readonly rightBefore?: IStage;\n\n  /**\n   * Inserts the new Stage as a child of the given Stage\n   * (changing its current child Stage, if it had one).\n   */\n  readonly justAfter?: IStage;\n}\n\n/**\n * Construction properties of a Pipeline Stage.\n */\nexport interface StageProps {\n  /**\n   * The physical, human-readable name to assign to this Pipeline Stage.\n   */\n  readonly stageName: string;\n\n  /**\n   * The list of Actions to create this Stage with.\n   * You can always add more Actions later by calling {@link IStage#addAction}.\n   */\n  readonly actions?: IAction[];\n}\n\nexport interface StageOptions extends StageProps {\n  readonly placement?: StagePlacement;\n}\n\nexport interface PipelineProps {\n  /**\n   * The S3 bucket used by this Pipeline to store artifacts.\n   *\n   * @default - A new S3 bucket will be created.\n   */\n  readonly artifactBucket?: s3.IBucket;\n\n  /**\n   * The IAM role to be assumed by this Pipeline.\n   *\n   * @default a new IAM role will be created.\n   */\n  readonly role?: iam.IRole;\n\n  /**\n   * Indicates whether to rerun the AWS CodePipeline pipeline after you update it.\n   *\n   * @default false\n   */\n  readonly restartExecutionOnUpdate?: boolean;\n\n  /**\n   * Name of the pipeline.\n   *\n   * @default - AWS CloudFormation generates an ID and uses that for the pipeline name.\n   */\n  readonly pipelineName?: string;\n\n  /**\n   * A map of region to S3 bucket name used for cross-region CodePipeline.\n   * For every Action that you specify targeting a different region than the Pipeline itself,\n   * if you don't provide an explicit Bucket for that region using this property,\n   * the construct will automatically create a Stack containing an S3 Bucket in that region.\n   *\n   * @default - None.\n   */\n  readonly crossRegionReplicationBuckets?: { [region: string]: s3.IBucket };\n\n  /**\n   * The list of Stages, in order,\n   * to create this Pipeline with.\n   * You can always add more Stages later by calling {@link Pipeline#addStage}.\n   *\n   * @default - None.\n   */\n  readonly stages?: StageProps[];\n\n  /**\n   * Create KMS keys for cross-account deployments.\n   *\n   * This controls whether the pipeline is enabled for cross-account deployments.\n   *\n   * By default cross-account deployments are enabled, but this feature requires\n   * that KMS Customer Master Keys are created which have a cost of $1/month.\n   *\n   * If you do not need cross-account deployments, you can set this to `false` to\n   * not create those keys and save on that cost (the artifact bucket will be\n   * encrypted with an AWS-managed key). However, cross-account deployments will\n   * no longer be possible.\n   *\n   * @default true\n   */\n  readonly crossAccountKeys?: boolean;\n\n  /**\n   * Enable KMS key rotation for the generated KMS keys.\n   *\n   * By default KMS key rotation is disabled, but will add an additional $1/month\n   * for each year the key exists when enabled.\n   *\n   * @default - false (key rotation is disabled)\n   */\n  readonly enableKeyRotation?: boolean;\n\n  /**\n   * Reuse the same cross region support stack for all pipelines in the App.\n   *\n   * @default - true (Use the same support stack for all pipelines in App)\n   */\n  readonly reuseCrossRegionSupportStacks?: boolean;\n}\n\nabstract class PipelineBase extends Resource implements IPipeline {\n  public abstract readonly pipelineName: string;\n  public abstract readonly pipelineArn: string;\n\n  /**\n   * Defines an event rule triggered by this CodePipeline.\n   *\n   * @param id Identifier for this event handler.\n   * @param options Additional options to pass to the event rule.\n   */\n  public onEvent(id: string, options: events.OnEventOptions = {}): events.Rule {\n    const rule = new events.Rule(this, id, options);\n    rule.addTarget(options.target);\n    rule.addEventPattern({\n      source: ['aws.codepipeline'],\n      resources: [this.pipelineArn],\n    });\n    return rule;\n  }\n\n  /**\n   * Defines an event rule triggered by the \"CodePipeline Pipeline Execution\n   * State Change\" event emitted from this pipeline.\n   *\n   * @param id Identifier for this event handler.\n   * @param options Additional options to pass to the event rule.\n   */\n  public onStateChange(id: string, options: events.OnEventOptions = {}): events.Rule {\n    const rule = this.onEvent(id, options);\n    rule.addEventPattern({\n      detailType: ['CodePipeline Pipeline Execution State Change'],\n    });\n    return rule;\n  }\n\n  public bindAsNotificationRuleSource(_scope: Construct): notifications.NotificationRuleSourceConfig {\n    return {\n      sourceArn: this.pipelineArn,\n    };\n  }\n\n  public notifyOn(\n    id: string,\n    target: notifications.INotificationRuleTarget,\n    options: PipelineNotifyOnOptions,\n  ): notifications.INotificationRule {\n    return new notifications.NotificationRule(this, id, {\n      ...options,\n      source: this,\n      targets: [target],\n    });\n  }\n\n  public notifyOnExecutionStateChange(\n    id: string,\n    target: notifications.INotificationRuleTarget,\n    options?: notifications.NotificationRuleOptions,\n  ): notifications.INotificationRule {\n    return this.notifyOn(id, target, {\n      ...options,\n      events: [\n        PipelineNotificationEvents.PIPELINE_EXECUTION_FAILED,\n        PipelineNotificationEvents.PIPELINE_EXECUTION_CANCELED,\n        PipelineNotificationEvents.PIPELINE_EXECUTION_STARTED,\n        PipelineNotificationEvents.PIPELINE_EXECUTION_RESUMED,\n        PipelineNotificationEvents.PIPELINE_EXECUTION_SUCCEEDED,\n        PipelineNotificationEvents.PIPELINE_EXECUTION_SUPERSEDED,\n      ],\n    });\n  }\n\n  public notifyOnAnyStageStateChange(\n    id: string,\n    target: notifications.INotificationRuleTarget,\n    options?: notifications.NotificationRuleOptions,\n  ): notifications.INotificationRule {\n    return this.notifyOn(id, target, {\n      ...options,\n      events: [\n        PipelineNotificationEvents.STAGE_EXECUTION_CANCELED,\n        PipelineNotificationEvents.STAGE_EXECUTION_FAILED,\n        PipelineNotificationEvents.STAGE_EXECUTION_RESUMED,\n        PipelineNotificationEvents.STAGE_EXECUTION_STARTED,\n        PipelineNotificationEvents.STAGE_EXECUTION_SUCCEEDED,\n      ],\n    });\n  }\n\n  public notifyOnAnyActionStateChange(\n    id: string,\n    target: notifications.INotificationRuleTarget,\n    options?: notifications.NotificationRuleOptions,\n  ): notifications.INotificationRule {\n    return this.notifyOn(id, target, {\n      ...options,\n      events: [\n        PipelineNotificationEvents.ACTION_EXECUTION_CANCELED,\n        PipelineNotificationEvents.ACTION_EXECUTION_FAILED,\n        PipelineNotificationEvents.ACTION_EXECUTION_STARTED,\n        PipelineNotificationEvents.ACTION_EXECUTION_SUCCEEDED,\n      ],\n    });\n  }\n\n  public notifyOnAnyManualApprovalStateChange(\n    id: string,\n    target: notifications.INotificationRuleTarget,\n    options?: notifications.NotificationRuleOptions,\n  ): notifications.INotificationRule {\n    return this.notifyOn(id, target, {\n      ...options,\n      events: [\n        PipelineNotificationEvents.MANUAL_APPROVAL_FAILED,\n        PipelineNotificationEvents.MANUAL_APPROVAL_NEEDED,\n        PipelineNotificationEvents.MANUAL_APPROVAL_SUCCEEDED,\n      ],\n    });\n  }\n}\n\n/**\n * An AWS CodePipeline pipeline with its associated IAM role and S3 bucket.\n *\n * @example\n * // create a pipeline\n * import * as codecommit from '@aws-cdk/aws-codecommit';\n *\n * const pipeline = new codepipeline.Pipeline(this, 'Pipeline');\n *\n * // add a stage\n * const sourceStage = pipeline.addStage({ stageName: 'Source' });\n *\n * // add a source action to the stage\n * declare const repo: codecommit.Repository;\n * declare const sourceArtifact: codepipeline.Artifact;\n * sourceStage.addAction(new codepipeline_actions.CodeCommitSourceAction({\n *   actionName: 'Source',\n *   output: sourceArtifact,\n *   repository: repo,\n * }));\n *\n * // ... add more stages\n */\nexport class Pipeline extends PipelineBase {\n  /**\n   * Import a pipeline into this app.\n   *\n   * @param scope the scope into which to import this pipeline\n   * @param id the logical ID of the returned pipeline construct\n   * @param pipelineArn The ARN of the pipeline (e.g. `arn:aws:codepipeline:us-east-1:123456789012:MyDemoPipeline`)\n   */\n  public static fromPipelineArn(scope: Construct, id: string, pipelineArn: string): IPipeline {\n    class Import extends PipelineBase {\n      public readonly pipelineName = Stack.of(scope).splitArn(pipelineArn, ArnFormat.SLASH_RESOURCE_NAME).resource;\n      public readonly pipelineArn = pipelineArn;\n    }\n\n    return new Import(scope, id);\n  }\n\n  /**\n   * The IAM role AWS CodePipeline will use to perform actions or assume roles for actions with\n   * a more specific IAM role.\n   */\n  public readonly role: iam.IRole;\n\n  /**\n   * ARN of this pipeline\n   */\n  public readonly pipelineArn: string;\n\n  /**\n   * The name of the pipeline\n   */\n  public readonly pipelineName: string;\n\n  /**\n   * The version of the pipeline\n   *\n   * @attribute\n   */\n  public readonly pipelineVersion: string;\n\n  /**\n   * Bucket used to store output artifacts\n   */\n  public readonly artifactBucket: s3.IBucket;\n\n  private readonly _stages = new Array<Stage>();\n  private readonly crossRegionBucketsPassed: boolean;\n  private readonly _crossRegionSupport: { [region: string]: CrossRegionSupport } = {};\n  private readonly _crossAccountSupport: { [account: string]: Stack } = {};\n  private readonly crossAccountKeys: boolean;\n  private readonly enableKeyRotation?: boolean;\n  private readonly reuseCrossRegionSupportStacks: boolean;\n\n  constructor(scope: Construct, id: string, props: PipelineProps = {}) {\n    super(scope, id, {\n      physicalName: props.pipelineName,\n    });\n\n    validateName('Pipeline', this.physicalName);\n\n    // only one of artifactBucket and crossRegionReplicationBuckets can be supplied\n    if (props.artifactBucket && props.crossRegionReplicationBuckets) {\n      throw new Error('Only one of artifactBucket and crossRegionReplicationBuckets can be specified!');\n    }\n\n    // @deprecated(v2): switch to default false\n    this.crossAccountKeys = props.crossAccountKeys ?? true;\n    this.enableKeyRotation = props.enableKeyRotation;\n\n    // Cross account keys must be set for key rotation to be enabled\n    if (this.enableKeyRotation && !this.crossAccountKeys) {\n      throw new Error(\"Setting 'enableKeyRotation' to true also requires 'crossAccountKeys' to be enabled\");\n    }\n\n    this.reuseCrossRegionSupportStacks = props.reuseCrossRegionSupportStacks ?? true;\n\n    // If a bucket has been provided, use it - otherwise, create a bucket.\n    let propsBucket = this.getArtifactBucketFromProps(props);\n\n    if (!propsBucket) {\n      let encryptionKey;\n\n      if (this.crossAccountKeys) {\n        encryptionKey = new kms.Key(this, 'ArtifactsBucketEncryptionKey', {\n          // remove the key - there is a grace period of a few days before it's gone for good,\n          // that should be enough for any emergency access to the bucket artifacts\n          removalPolicy: RemovalPolicy.DESTROY,\n          enableKeyRotation: this.enableKeyRotation,\n        });\n        // add an alias to make finding the key in the console easier\n        new kms.Alias(this, 'ArtifactsBucketEncryptionKeyAlias', {\n          aliasName: this.generateNameForDefaultBucketKeyAlias(),\n          targetKey: encryptionKey,\n          removalPolicy: RemovalPolicy.DESTROY, // destroy the alias along with the key\n        });\n      }\n\n      propsBucket = new s3.Bucket(this, 'ArtifactsBucket', {\n        bucketName: PhysicalName.GENERATE_IF_NEEDED,\n        encryptionKey,\n        encryption: encryptionKey ? s3.BucketEncryption.KMS : s3.BucketEncryption.KMS_MANAGED,\n        enforceSSL: true,\n        blockPublicAccess: new s3.BlockPublicAccess(s3.BlockPublicAccess.BLOCK_ALL),\n        removalPolicy: RemovalPolicy.RETAIN,\n      });\n    }\n    this.artifactBucket = propsBucket;\n\n    // If a role has been provided, use it - otherwise, create a role.\n    this.role = props.role || new iam.Role(this, 'Role', {\n      assumedBy: new iam.ServicePrincipal('codepipeline.amazonaws.com'),\n    });\n\n    const codePipeline = new CfnPipeline(this, 'Resource', {\n      artifactStore: Lazy.any({ produce: () => this.renderArtifactStoreProperty() }),\n      artifactStores: Lazy.any({ produce: () => this.renderArtifactStoresProperty() }),\n      stages: Lazy.any({ produce: () => this.renderStages() }),\n      roleArn: this.role.roleArn,\n      restartExecutionOnUpdate: props && props.restartExecutionOnUpdate,\n      name: this.physicalName,\n    });\n\n    // this will produce a DependsOn for both the role and the policy resources.\n    codePipeline.node.addDependency(this.role);\n\n    this.artifactBucket.grantReadWrite(this.role);\n    this.pipelineName = this.getResourceNameAttribute(codePipeline.ref);\n    this.pipelineVersion = codePipeline.attrVersion;\n    this.crossRegionBucketsPassed = !!props.crossRegionReplicationBuckets;\n\n    for (const [region, replicationBucket] of Object.entries(props.crossRegionReplicationBuckets || {})) {\n      this._crossRegionSupport[region] = {\n        replicationBucket,\n        stack: Stack.of(replicationBucket),\n      };\n    }\n\n    // Does not expose a Fn::GetAtt for the ARN so we'll have to make it ourselves\n    this.pipelineArn = Stack.of(this).formatArn({\n      service: 'codepipeline',\n      resource: this.pipelineName,\n    });\n\n    for (const stage of props.stages || []) {\n      this.addStage(stage);\n    }\n\n    this.node.addValidation({ validate: () => this.validatePipeline() });\n  }\n\n  /**\n   * Creates a new Stage, and adds it to this Pipeline.\n   *\n   * @param props the creation properties of the new Stage\n   * @returns the newly created Stage\n   */\n  public addStage(props: StageOptions): IStage {\n    // check for duplicate Stages and names\n    if (this._stages.find(s => s.stageName === props.stageName)) {\n      throw new Error(`Stage with duplicate name '${props.stageName}' added to the Pipeline`);\n    }\n\n    const stage = new Stage(props, this);\n\n    const index = props.placement\n      ? this.calculateInsertIndexFromPlacement(props.placement)\n      : this.stageCount;\n\n    this._stages.splice(index, 0, stage);\n\n    return stage;\n  }\n\n  /**\n   * Adds a statement to the pipeline role.\n   */\n  public addToRolePolicy(statement: iam.PolicyStatement) {\n    this.role.addToPrincipalPolicy(statement);\n  }\n\n  /**\n   * Get the number of Stages in this Pipeline.\n   */\n  public get stageCount(): number {\n    return this._stages.length;\n  }\n\n  /**\n   * Returns the stages that comprise the pipeline.\n   *\n   * **Note**: the returned array is a defensive copy,\n   * so adding elements to it has no effect.\n   * Instead, use the {@link addStage} method if you want to add more stages\n   * to the pipeline.\n   */\n  public get stages(): IStage[] {\n    return this._stages.slice();\n  }\n\n  /**\n   * Access one of the pipeline's stages by stage name\n   */\n  public stage(stageName: string): IStage {\n    for (const stage of this._stages) {\n      if (stage.stageName === stageName) {\n        return stage;\n      }\n    }\n    throw new Error(`Pipeline does not contain a stage named '${stageName}'. Available stages: ${this._stages.map(s => s.stageName).join(', ')}`);\n  }\n\n  /**\n   * Returns all of the {@link CrossRegionSupportStack}s that were generated automatically\n   * when dealing with Actions that reside in a different region than the Pipeline itself.\n   *\n   */\n  public get crossRegionSupport(): { [region: string]: CrossRegionSupport } {\n    const ret: { [region: string]: CrossRegionSupport } = {};\n    Object.keys(this._crossRegionSupport).forEach((key) => {\n      ret[key] = this._crossRegionSupport[key];\n    });\n    return ret;\n  }\n\n  /** @internal */\n  public _attachActionToPipeline(stage: Stage, action: IAction, actionScope: Construct): FullActionDescriptor {\n    const richAction = new RichAction(action, this);\n\n    // handle cross-region actions here\n    const crossRegionInfo = this.ensureReplicationResourcesExistFor(richAction);\n\n    // get the role for the given action, handling if it's cross-account\n    const actionRole = this.getRoleForAction(stage, richAction, actionScope);\n\n    // // CodePipeline Variables\n    validateNamespaceName(richAction.actionProperties.variablesNamespace);\n\n    // bind the Action (type h4x)\n    const actionConfig = richAction.bind(actionScope, stage, {\n      role: actionRole ? actionRole : this.role,\n      bucket: crossRegionInfo.artifactBucket,\n    });\n\n    return new FullActionDescriptor({\n      // must be 'action', not 'richAction',\n      // as those are returned by the IStage.actions property,\n      // and it's important customers of Pipeline get the same instance\n      // back as they added to the pipeline\n      action,\n      actionConfig,\n      actionRole,\n      actionRegion: crossRegionInfo.region,\n    });\n  }\n\n  /**\n   * Validate the pipeline structure\n   *\n   * Validation happens according to the rules documented at\n   *\n   * https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#pipeline-requirements\n   */\n  private validatePipeline(): string[] {\n    return [\n      ...this.validateSourceActionLocations(),\n      ...this.validateHasStages(),\n      ...this.validateStages(),\n      ...this.validateArtifacts(),\n    ];\n  }\n\n  private ensureReplicationResourcesExistFor(action: RichAction): CrossRegionInfo {\n    if (!action.isCrossRegion) {\n      return {\n        artifactBucket: this.artifactBucket,\n      };\n    }\n\n    // The action has a specific region,\n    // require the pipeline to have a known region as well.\n    this.requireRegion();\n\n    // source actions have to be in the same region as the pipeline\n    if (action.actionProperties.category === ActionCategory.SOURCE) {\n      throw new Error(`Source action '${action.actionProperties.actionName}' must be in the same region as the pipeline`);\n    }\n\n    // check whether we already have a bucket in that region,\n    // either passed from the outside or previously created\n    const crossRegionSupport = this.obtainCrossRegionSupportFor(action);\n\n    // the stack containing the replication bucket must be deployed before the pipeline\n    Stack.of(this).addDependency(crossRegionSupport.stack);\n    // The Pipeline role must be able to replicate to that bucket\n    crossRegionSupport.replicationBucket.grantReadWrite(this.role);\n\n    return {\n      artifactBucket: crossRegionSupport.replicationBucket,\n      region: action.effectiveRegion,\n    };\n  }\n\n  /**\n   * Get or create the cross-region support construct for the given action\n   */\n  private obtainCrossRegionSupportFor(action: RichAction) {\n    // this method is never called for non cross-region actions\n    const actionRegion = action.effectiveRegion!;\n    let crossRegionSupport = this._crossRegionSupport[actionRegion];\n    if (!crossRegionSupport) {\n      // we need to create scaffolding resources for this region\n      const otherStack = action.resourceStack;\n      crossRegionSupport = this.createSupportResourcesForRegion(otherStack, actionRegion);\n      this._crossRegionSupport[actionRegion] = crossRegionSupport;\n    }\n    return crossRegionSupport;\n  }\n\n  private createSupportResourcesForRegion(otherStack: Stack | undefined, actionRegion: string): CrossRegionSupport {\n    // if we have a stack from the resource passed - use that!\n    if (otherStack) {\n      // check if the stack doesn't have this magic construct already\n      const id = `CrossRegionReplicationSupport-d823f1d8-a990-4e5c-be18-4ac698532e65-${actionRegion}`;\n      let crossRegionSupportConstruct = otherStack.node.tryFindChild(id) as CrossRegionSupportConstruct;\n      if (!crossRegionSupportConstruct) {\n        crossRegionSupportConstruct = new CrossRegionSupportConstruct(otherStack, id, {\n          createKmsKey: this.crossAccountKeys,\n          enableKeyRotation: this.enableKeyRotation,\n        });\n      }\n\n      return {\n        replicationBucket: crossRegionSupportConstruct.replicationBucket,\n        stack: otherStack,\n      };\n    }\n\n    // otherwise - create a stack with the resources needed for replication across regions\n    const pipelineStack = Stack.of(this);\n    const pipelineAccount = pipelineStack.account;\n    if (Token.isUnresolved(pipelineAccount)) {\n      throw new Error(\"You need to specify an explicit account when using CodePipeline's cross-region support\");\n    }\n\n    const app = this.supportScope();\n    const supportStackId = `cross-region-stack-${this.reuseCrossRegionSupportStacks ? pipelineAccount : pipelineStack.stackName}:${actionRegion}`;\n    let supportStack = app.node.tryFindChild(supportStackId) as CrossRegionSupportStack;\n    if (!supportStack) {\n      supportStack = new CrossRegionSupportStack(app, supportStackId, {\n        pipelineStackName: pipelineStack.stackName,\n        region: actionRegion,\n        account: pipelineAccount,\n        synthesizer: this.getCrossRegionSupportSynthesizer(),\n        createKmsKey: this.crossAccountKeys,\n        enableKeyRotation: this.enableKeyRotation,\n      });\n    }\n\n    return {\n      stack: supportStack,\n      replicationBucket: supportStack.replicationBucket,\n    };\n  }\n\n  private getCrossRegionSupportSynthesizer(): IStackSynthesizer | undefined {\n    if (this.stack.synthesizer instanceof DefaultStackSynthesizer) {\n      // if we have the new synthesizer,\n      // we need a bootstrapless copy of it,\n      // because we don't want to require bootstrapping the environment\n      // of the pipeline account in this replication region\n      return new BootstraplessSynthesizer({\n        deployRoleArn: this.stack.synthesizer.deployRoleArn,\n        cloudFormationExecutionRoleArn: this.stack.synthesizer.cloudFormationExecutionRoleArn,\n      });\n    } else {\n      // any other synthesizer: just return undefined\n      // (ie., use the default based on the context settings)\n      return undefined;\n    }\n  }\n\n  private generateNameForDefaultBucketKeyAlias(): string {\n    const prefix = 'alias/codepipeline-';\n    const maxAliasLength = 256;\n    const uniqueId = Names.uniqueId(this);\n    // take the last 256 - (prefix length) characters of uniqueId\n    const startIndex = Math.max(0, uniqueId.length - (maxAliasLength - prefix.length));\n    return prefix + uniqueId.substring(startIndex).toLowerCase();\n  }\n\n  /**\n   * Gets the role used for this action,\n   * including handling the case when the action is supposed to be cross-account.\n   *\n   * @param stage the stage the action belongs to\n   * @param action the action to return/create a role for\n   * @param actionScope the scope, unique to the action, to create new resources in\n   */\n  private getRoleForAction(stage: Stage, action: RichAction, actionScope: Construct): iam.IRole | undefined {\n    const pipelineStack = Stack.of(this);\n\n    let actionRole = this.getRoleFromActionPropsOrGenerateIfCrossAccount(stage, action);\n\n    if (!actionRole && this.isAwsOwned(action)) {\n      // generate a Role for this specific Action\n      actionRole = new iam.Role(actionScope, 'CodePipelineActionRole', {\n        assumedBy: new iam.AccountPrincipal(pipelineStack.account),\n      });\n    }\n\n    // the pipeline role needs assumeRole permissions to the action role\n    if (actionRole) {\n      this.role.addToPrincipalPolicy(new iam.PolicyStatement({\n        actions: ['sts:AssumeRole'],\n        resources: [actionRole.roleArn],\n      }));\n    }\n\n    return actionRole;\n  }\n\n  private getRoleFromActionPropsOrGenerateIfCrossAccount(stage: Stage, action: RichAction): iam.IRole | undefined {\n    const pipelineStack = Stack.of(this);\n\n    // if we have a cross-account action, the pipeline's bucket must have a KMS key\n    // (otherwise we can't configure cross-account trust policies)\n    if (action.isCrossAccount) {\n      const artifactBucket = this.ensureReplicationResourcesExistFor(action).artifactBucket;\n      if (!artifactBucket.encryptionKey) {\n        throw new Error(\n          `Artifact Bucket must have a KMS Key to add cross-account action '${action.actionProperties.actionName}' ` +\n          `(pipeline account: '${renderEnvDimension(this.env.account)}', action account: '${renderEnvDimension(action.effectiveAccount)}'). ` +\n          'Create Pipeline with \\'crossAccountKeys: true\\' (or pass an existing Bucket with a key)',\n        );\n      }\n    }\n\n    // if a Role has been passed explicitly, always use it\n    // (even if the backing resource is from a different account -\n    // this is how the user can override our default support logic)\n    if (action.actionProperties.role) {\n      if (this.isAwsOwned(action)) {\n        // the role has to be deployed before the pipeline\n        // (our magical cross-stack dependencies will not work,\n        // because the role might be from a different environment),\n        // but _only_ if it's a new Role -\n        // an imported Role should not add the dependency\n        if (action.actionProperties.role instanceof iam.Role) {\n          const roleStack = Stack.of(action.actionProperties.role);\n          pipelineStack.addDependency(roleStack);\n        }\n\n        return action.actionProperties.role;\n      } else {\n        // ...except if the Action is not owned by 'AWS',\n        // as that would be rejected by CodePipeline at deploy time\n        throw new Error(\"Specifying a Role is not supported for actions with an owner different than 'AWS' - \" +\n          `got '${action.actionProperties.owner}' (Action: '${action.actionProperties.actionName}' in Stage: '${stage.stageName}')`);\n      }\n    }\n\n    // if we don't have a Role passed,\n    // and the action is cross-account,\n    // generate a Role in that other account stack\n    const otherAccountStack = this.getOtherStackIfActionIsCrossAccount(action);\n    if (!otherAccountStack) {\n      return undefined;\n    }\n\n    // generate a role in the other stack, that the Pipeline will assume for executing this action\n    const ret = new iam.Role(otherAccountStack,\n      `${Names.uniqueId(this)}-${stage.stageName}-${action.actionProperties.actionName}-ActionRole`, {\n        assumedBy: new iam.AccountPrincipal(pipelineStack.account),\n        roleName: PhysicalName.GENERATE_IF_NEEDED,\n      });\n    // the other stack with the role has to be deployed before the pipeline stack\n    // (CodePipeline verifies you can assume the action Role on creation)\n    pipelineStack.addDependency(otherAccountStack);\n\n    return ret;\n  }\n\n  /**\n   * Returns the Stack this Action belongs to if this is a cross-account Action.\n   * If this Action is not cross-account (i.e., it lives in the same account as the Pipeline),\n   * it returns undefined.\n   *\n   * @param action the Action to return the Stack for\n   */\n  private getOtherStackIfActionIsCrossAccount(action: IAction): Stack | undefined {\n    const targetAccount = action.actionProperties.resource\n      ? action.actionProperties.resource.env.account\n      : action.actionProperties.account;\n\n    if (targetAccount === undefined) {\n      // if the account of the Action is not specified,\n      // then it defaults to the same account the pipeline itself is in\n      return undefined;\n    }\n\n    // check whether the action's account is a static string\n    if (Token.isUnresolved(targetAccount)) {\n      if (Token.isUnresolved(this.env.account)) {\n        // the pipeline is also env-agnostic, so that's fine\n        return undefined;\n      } else {\n        throw new Error(`The 'account' property must be a concrete value (action: '${action.actionProperties.actionName}')`);\n      }\n    }\n\n    // At this point, we know that the action's account is a static string.\n    // In this case, the pipeline's account must also be a static string.\n    if (Token.isUnresolved(this.env.account)) {\n      throw new Error('Pipeline stack which uses cross-environment actions must have an explicitly set account');\n    }\n\n    // at this point, we know that both the Pipeline's account,\n    // and the action-backing resource's account are static strings\n\n    // if they are identical - nothing to do (the action is not cross-account)\n    if (this.env.account === targetAccount) {\n      return undefined;\n    }\n\n    // at this point, we know that the action is certainly cross-account,\n    // so we need to return a Stack in its account to create the helper Role in\n\n    const candidateActionResourceStack = action.actionProperties.resource\n      ? Stack.of(action.actionProperties.resource)\n      : undefined;\n    if (candidateActionResourceStack?.account === targetAccount) {\n      // we always use the \"latest\" action-backing resource's Stack for this account,\n      // even if a different one was used earlier\n      this._crossAccountSupport[targetAccount] = candidateActionResourceStack;\n      return candidateActionResourceStack;\n    }\n\n    let targetAccountStack: Stack | undefined = this._crossAccountSupport[targetAccount];\n    if (!targetAccountStack) {\n      const stackId = `cross-account-support-stack-${targetAccount}`;\n      const app = this.supportScope();\n      targetAccountStack = app.node.tryFindChild(stackId) as Stack;\n      if (!targetAccountStack) {\n        const actionRegion = action.actionProperties.resource\n          ? action.actionProperties.resource.env.region\n          : action.actionProperties.region;\n        const pipelineStack = Stack.of(this);\n        targetAccountStack = new Stack(app, stackId, {\n          stackName: `${pipelineStack.stackName}-support-${targetAccount}`,\n          env: {\n            account: targetAccount,\n            region: actionRegion ?? pipelineStack.region,\n          },\n        });\n      }\n      this._crossAccountSupport[targetAccount] = targetAccountStack;\n    }\n    return targetAccountStack;\n  }\n\n  private isAwsOwned(action: IAction) {\n    const owner = action.actionProperties.owner;\n    return !owner || owner === 'AWS';\n  }\n\n  private getArtifactBucketFromProps(props: PipelineProps): s3.IBucket | undefined {\n    if (props.artifactBucket) {\n      return props.artifactBucket;\n    }\n    if (props.crossRegionReplicationBuckets) {\n      const pipelineRegion = this.requireRegion();\n      return props.crossRegionReplicationBuckets[pipelineRegion];\n    }\n    return undefined;\n  }\n\n  private calculateInsertIndexFromPlacement(placement: StagePlacement): number {\n    // check if at most one placement property was provided\n    const providedPlacementProps = ['rightBefore', 'justAfter', 'atIndex']\n      .filter((prop) => (placement as any)[prop] !== undefined);\n    if (providedPlacementProps.length > 1) {\n      throw new Error('Error adding Stage to the Pipeline: ' +\n        'you can only provide at most one placement property, but ' +\n        `'${providedPlacementProps.join(', ')}' were given`);\n    }\n\n    if (placement.rightBefore !== undefined) {\n      const targetIndex = this.findStageIndex(placement.rightBefore);\n      if (targetIndex === -1) {\n        throw new Error('Error adding Stage to the Pipeline: ' +\n          `the requested Stage to add it before, '${placement.rightBefore.stageName}', was not found`);\n      }\n      return targetIndex;\n    }\n\n    if (placement.justAfter !== undefined) {\n      const targetIndex = this.findStageIndex(placement.justAfter);\n      if (targetIndex === -1) {\n        throw new Error('Error adding Stage to the Pipeline: ' +\n          `the requested Stage to add it after, '${placement.justAfter.stageName}', was not found`);\n      }\n      return targetIndex + 1;\n    }\n\n    return this.stageCount;\n  }\n\n  private findStageIndex(targetStage: IStage) {\n    return this._stages.findIndex(stage => stage === targetStage);\n  }\n\n  private validateSourceActionLocations(): string[] {\n    const errors = new Array<string>();\n    let firstStage = true;\n    for (const stage of this._stages) {\n      const onlySourceActionsPermitted = firstStage;\n      for (const action of stage.actionDescriptors) {\n        errors.push(...validateSourceAction(onlySourceActionsPermitted, action.category, action.actionName, stage.stageName));\n      }\n      firstStage = false;\n    }\n    return errors;\n  }\n\n  private validateHasStages(): string[] {\n    if (this.stageCount < 2) {\n      return ['Pipeline must have at least two stages'];\n    }\n    return [];\n  }\n\n  private validateStages(): string[] {\n    const ret = new Array<string>();\n    for (const stage of this._stages) {\n      ret.push(...stage.validate());\n    }\n    return ret;\n  }\n\n  private validateArtifacts(): string[] {\n    const ret = new Array<string>();\n\n    const producers: Record<string, PipelineLocation> = {};\n    const firstConsumers: Record<string, PipelineLocation> = {};\n\n    for (const [stageIndex, stage] of enumerate(this._stages)) {\n      // For every output artifact, get the producer\n      for (const action of stage.actionDescriptors) {\n        const actionLoc = new PipelineLocation(stageIndex, stage, action);\n\n        for (const outputArtifact of action.outputs) {\n          // output Artifacts always have a name set\n          const name = outputArtifact.artifactName!;\n          if (producers[name]) {\n            ret.push(`Both Actions '${producers[name].actionName}' and '${action.actionName}' are producting Artifact '${name}'. Every artifact can only be produced once.`);\n            continue;\n          }\n\n          producers[name] = actionLoc;\n        }\n\n        // For every input artifact, get the first consumer\n        for (const inputArtifact of action.inputs) {\n          const name = inputArtifact.artifactName;\n          if (!name) {\n            ret.push(`Action '${action.actionName}' is using an unnamed input Artifact, which is not being produced in this pipeline`);\n            continue;\n          }\n\n          firstConsumers[name] = firstConsumers[name] ? firstConsumers[name].first(actionLoc) : actionLoc;\n        }\n      }\n    }\n\n    // Now validate that every input artifact is produced before it's\n    // being consumed.\n    for (const [artifactName, consumerLoc] of Object.entries(firstConsumers)) {\n      const producerLoc = producers[artifactName];\n      if (!producerLoc) {\n        ret.push(`Action '${consumerLoc.actionName}' is using input Artifact '${artifactName}', which is not being produced in this pipeline`);\n        continue;\n      }\n\n      if (consumerLoc.beforeOrEqual(producerLoc)) {\n        ret.push(`${consumerLoc} is consuming input Artifact '${artifactName}' before it is being produced at ${producerLoc}`);\n      }\n    }\n\n    return ret;\n  }\n\n  private renderArtifactStoresProperty(): CfnPipeline.ArtifactStoreMapProperty[] | undefined {\n    if (!this.crossRegion) { return undefined; }\n\n    // add the Pipeline's artifact store\n    const primaryRegion = this.requireRegion();\n    this._crossRegionSupport[primaryRegion] = {\n      replicationBucket: this.artifactBucket,\n      stack: Stack.of(this),\n    };\n\n    return Object.entries(this._crossRegionSupport).map(([region, support]) => ({\n      region,\n      artifactStore: this.renderArtifactStore(support.replicationBucket),\n    }));\n  }\n\n  private renderArtifactStoreProperty(): CfnPipeline.ArtifactStoreProperty | undefined {\n    if (this.crossRegion) { return undefined; }\n    return this.renderPrimaryArtifactStore();\n  }\n\n  private renderPrimaryArtifactStore(): CfnPipeline.ArtifactStoreProperty {\n    return this.renderArtifactStore(this.artifactBucket);\n  }\n\n  private renderArtifactStore(bucket: s3.IBucket): CfnPipeline.ArtifactStoreProperty {\n    let encryptionKey: CfnPipeline.EncryptionKeyProperty | undefined;\n    const bucketKey = bucket.encryptionKey;\n    if (bucketKey) {\n      encryptionKey = {\n        type: 'KMS',\n        id: bucketKey.keyArn,\n      };\n    }\n\n    return {\n      type: 'S3',\n      location: bucket.bucketName,\n      encryptionKey,\n    };\n  }\n\n  private get crossRegion(): boolean {\n    if (this.crossRegionBucketsPassed) { return true; }\n    return this._stages.some(stage => stage.actionDescriptors.some(action => action.region !== undefined));\n  }\n\n  private renderStages(): CfnPipeline.StageDeclarationProperty[] {\n    return this._stages.map(stage => stage.render());\n  }\n\n  private requireRegion(): string {\n    const region = this.env.region;\n    if (Token.isUnresolved(region)) {\n      throw new Error('Pipeline stack which uses cross-environment actions must have an explicitly set region');\n    }\n    return region;\n  }\n\n  private supportScope(): CdkStage {\n    const scope = CdkStage.of(this);\n    if (!scope) {\n      throw new Error('Pipeline stack which uses cross-environment actions must be part of a CDK App or Stage');\n    }\n    return scope;\n  }\n}\n\n/**\n * An interface representing resources generated in order to support\n * the cross-region capabilities of CodePipeline.\n * You get instances of this interface from the {@link Pipeline#crossRegionSupport} property.\n *\n */\nexport interface CrossRegionSupport {\n  /**\n   * The Stack that has been created to house the replication Bucket\n   * required for this  region.\n   */\n  readonly stack: Stack;\n\n  /**\n   * The replication Bucket used by CodePipeline to operate in this region.\n   * Belongs to {@link stack}.\n   */\n  readonly replicationBucket: s3.IBucket;\n}\n\ninterface CrossRegionInfo {\n  readonly artifactBucket: s3.IBucket;\n\n  readonly region?: string;\n}\n\nfunction enumerate<A>(xs: A[]): Array<[number, A]> {\n  const ret = new Array<[number, A]>();\n  for (let i = 0; i < xs.length; i++) {\n    ret.push([i, xs[i]]);\n  }\n  return ret;\n}\n\nclass PipelineLocation {\n  constructor(private readonly stageIndex: number, private readonly stage: IStage, private readonly action: FullActionDescriptor) {\n  }\n\n  public get stageName() {\n    return this.stage.stageName;\n  }\n\n  public get actionName() {\n    return this.action.actionName;\n  }\n\n  /**\n   * Returns whether a is before or the same order as b\n   */\n  public beforeOrEqual(rhs: PipelineLocation) {\n    if (this.stageIndex !== rhs.stageIndex) { return rhs.stageIndex < rhs.stageIndex; }\n    return this.action.runOrder <= rhs.action.runOrder;\n  }\n\n  /**\n   * Returns the first location between this and the other one\n   */\n  public first(rhs: PipelineLocation) {\n    return this.beforeOrEqual(rhs) ? this : rhs;\n  }\n\n  public toString() {\n    // runOrders are 1-based, so make the stageIndex also 1-based otherwise it's going to be confusing.\n    return `Stage ${this.stageIndex + 1} Action ${this.action.runOrder} ('${this.stageName}'/'${this.actionName}')`;\n  }\n}\n\n/**\n * Render an env dimension without showing the ugly stringified tokens\n */\nfunction renderEnvDimension(s: string | undefined) {\n  return Token.isUnresolved(s) ? '(current)' : s;\n}\n"],
  "mappings": "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",
  "names": []
}
