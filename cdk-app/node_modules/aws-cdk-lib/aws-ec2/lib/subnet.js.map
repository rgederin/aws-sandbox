{
  "version": 3,
  "sources": ["subnet.ts"],
  "sourcesContent": ["import { CidrBlock, NetworkUtils } from './network-util';\nimport { ISubnet } from './vpc';\n\n/**\n * Contains logic which chooses a set of subnets from a larger list, in conjunction\n * with SubnetSelection, to determine where to place AWS resources such as VPC\n * endpoints, EC2 instances, etc.\n */\nexport abstract class SubnetFilter {\n\n  /**\n   * Chooses subnets by id.\n   */\n  public static byIds(subnetIds: string[]): SubnetFilter {\n    return new SubnetIdSubnetFilter(subnetIds);\n  }\n\n  /**\n   * Chooses subnets which are in one of the given availability zones.\n  */\n  public static availabilityZones(availabilityZones: string[]): SubnetFilter {\n    return new AvailabilityZoneSubnetFilter(availabilityZones);\n  }\n\n  /**\n   * Chooses subnets such that there is at most one per availability zone.\n  */\n  public static onePerAz(): SubnetFilter {\n    return new OnePerAZSubnetFilter();\n  }\n\n  /**\n   * Chooses subnets which contain any of the specified IP addresses.\n  */\n  public static containsIpAddresses(ipv4addrs: string[]): SubnetFilter {\n    return new ContainsIpAddressesSubnetFilter(ipv4addrs);\n  }\n\n  /**\n   * Chooses subnets which have the provided CIDR netmask.\n   */\n  public static byCidrMask(mask: number): SubnetFilter {\n    return new CidrMaskSubnetFilter(mask);\n  }\n\n  /**\n   * Executes the subnet filtering logic, returning a filtered set of subnets.\n   */\n  public selectSubnets(_subnets: ISubnet[]): ISubnet[] {\n    throw new Error('Cannot select subnets with an abstract SubnetFilter. `selectSubnets` needs to be implmemented.');\n  }\n}\n\n/**\n * Chooses subnets which are in one of the given availability zones.\n */\nclass AvailabilityZoneSubnetFilter extends SubnetFilter {\n\n  private readonly availabilityZones: string[];\n\n  constructor(availabilityZones: string[]) {\n    super();\n    this.availabilityZones = availabilityZones;\n  }\n\n  /**\n   * Executes the subnet filtering logic.\n   */\n  public selectSubnets(subnets: ISubnet[]): ISubnet[] {\n    return subnets.filter(s => this.availabilityZones.includes(s.availabilityZone));\n  }\n}\n\n/**\n * Chooses subnets such that there is at most one per availability zone.\n */\nclass OnePerAZSubnetFilter extends SubnetFilter {\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Executes the subnet filtering logic.\n   */\n  public selectSubnets(subnets: ISubnet[]): ISubnet[] {\n    return this.retainOnePerAz(subnets);\n  }\n\n  private retainOnePerAz(subnets: ISubnet[]): ISubnet[] {\n    const azsSeen = new Set<string>();\n    return subnets.filter(subnet => {\n      if (azsSeen.has(subnet.availabilityZone)) { return false; }\n      azsSeen.add(subnet.availabilityZone);\n      return true;\n    });\n  }\n}\n\n/**\n * Chooses subnets which contain any of the specified IP addresses.\n */\nclass ContainsIpAddressesSubnetFilter extends SubnetFilter {\n\n  private readonly ipAddresses: string[];\n\n  constructor(ipAddresses: string[]) {\n    super();\n    this.ipAddresses = ipAddresses;\n  }\n\n  /**\n   * Executes the subnet filtering logic.\n   */\n  public selectSubnets(subnets: ISubnet[]): ISubnet[] {\n    return this.retainByIp(subnets, this.ipAddresses);\n  }\n\n  private retainByIp(subnets: ISubnet[], ips: string[]): ISubnet[] {\n    const cidrBlockObjs = ips.map(ip => {\n      const ipNum = NetworkUtils.ipToNum(ip);\n      return new CidrBlock(ipNum, 32);\n    });\n    return subnets.filter(s => {\n      const subnetCidrBlock = new CidrBlock(s.ipv4CidrBlock);\n      return cidrBlockObjs.some(cidr => subnetCidrBlock.containsCidr(cidr));\n    });\n  }\n}\n\n/**\n * Chooses subnets based on the subnetId\n */\nclass SubnetIdSubnetFilter extends SubnetFilter {\n\n  private readonly subnetIds: string[];\n\n  constructor(subnetIds: string[]) {\n    super();\n    this.subnetIds = subnetIds;\n  }\n\n  /**\n   * Executes the subnet filtering logic.\n   */\n  public selectSubnets(subnets: ISubnet[]): ISubnet[] {\n    return subnets.filter(subnet => this.subnetIds.includes(subnet.subnetId));\n  }\n}\n\n/**\n * Chooses subnets based on the CIDR Netmask\n */\nclass CidrMaskSubnetFilter extends SubnetFilter {\n  private readonly mask: number\n\n  constructor(mask: number) {\n    super();\n    this.mask = mask;\n  }\n\n  /**\n   * Executes the subnet filtering logic.\n   */\n  public selectSubnets(subnets: ISubnet[]): ISubnet[] {\n    return subnets.filter(subnet => {\n      const subnetCidr = new CidrBlock(subnet.ipv4CidrBlock);\n      return subnetCidr.mask === this.mask;\n    });\n  }\n}\n"],
  "mappings": "wJAAA,eAAA,QAAA,kBAQA,kBAAkC,OAKlB,OAAM,UAAmB,CACrC,MAAO,IAAI,sBAAqB,iBAMpB,mBAAkB,kBAA2B,CACzD,MAAO,IAAI,8BAA6B,yBAM5B,WAAQ,CACpB,MAAO,IAAI,4BAMC,qBAAoB,UAAmB,CACnD,MAAO,IAAI,iCAAgC,iBAM/B,YAAW,KAAY,CACnC,MAAO,IAAI,sBAAqB,MAM3B,cAAc,SAAmB,CACtC,KAAM,IAAI,OAAM,mGAzCpB,QAAA,aAAA,8GAgDA,0CAA2C,aAAY,CAIrD,YAAY,kBAA2B,CACrC,QACA,KAAK,kBAAoB,kBAMpB,cAAc,QAAkB,CACrC,MAAO,SAAQ,OAAO,GAAK,KAAK,kBAAkB,SAAS,EAAE,oBAOjE,kCAAmC,aAAY,CAE7C,aAAA,CACE,QAMK,cAAc,QAAkB,CACrC,MAAO,MAAK,eAAe,SAGrB,eAAe,QAAkB,CACvC,KAAM,SAAU,GAAI,KACpB,MAAO,SAAQ,OAAO,QAChB,QAAQ,IAAI,OAAO,kBAA4B,GACnD,SAAQ,IAAI,OAAO,kBACZ,MAQb,6CAA8C,aAAY,CAIxD,YAAY,YAAqB,CAC/B,QACA,KAAK,YAAc,YAMd,cAAc,QAAkB,CACrC,MAAO,MAAK,WAAW,QAAS,KAAK,aAG/B,WAAW,QAAoB,IAAa,CAClD,KAAM,eAAgB,IAAI,IAAI,IAAK,CACjC,KAAM,OAAQ,eAAA,aAAa,QAAQ,IACnC,MAAO,IAAI,gBAAA,UAAU,MAAO,MAE9B,MAAO,SAAQ,OAAO,GAAI,CACxB,KAAM,iBAAkB,GAAI,gBAAA,UAAU,EAAE,eACxC,MAAO,eAAc,KAAK,MAAQ,gBAAgB,aAAa,UAQrE,kCAAmC,aAAY,CAI7C,YAAY,UAAmB,CAC7B,QACA,KAAK,UAAY,UAMZ,cAAc,QAAkB,CACrC,MAAO,SAAQ,OAAO,QAAU,KAAK,UAAU,SAAS,OAAO,YAOnE,kCAAmC,aAAY,CAG7C,YAAY,KAAY,CACtB,QACA,KAAK,KAAO,KAMP,cAAc,QAAkB,CACrC,MAAO,SAAQ,OAAO,QAEb,AADY,GAAI,gBAAA,UAAU,OAAO,eACtB,OAAS,KAAK",
  "names": []
}
