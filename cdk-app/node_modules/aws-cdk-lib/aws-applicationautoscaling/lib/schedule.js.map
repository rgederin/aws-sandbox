{
  "version": 3,
  "sources": ["schedule.ts"],
  "sourcesContent": ["import { Duration } from '../../core';\n\n/**\n * Schedule for scheduled scaling actions\n */\nexport abstract class Schedule {\n  /**\n   * Construct a schedule from a literal schedule expression\n   *\n   * @param expression The expression to use. Must be in a format that Application AutoScaling will recognize\n   */\n  public static expression(expression: string): Schedule {\n    return new LiteralSchedule(expression);\n  }\n\n  /**\n   * Construct a schedule from an interval and a time unit\n   */\n  public static rate(duration: Duration): Schedule {\n    if (duration.isUnresolved()) {\n      const validDurationUnit = ['minute', 'minutes', 'hour', 'hours', 'day', 'days'];\n      if (!validDurationUnit.includes(duration.unitLabel())) {\n        throw new Error(\"Allowed units for scheduling are: 'minute', 'minutes', 'hour', 'hours', 'day' or 'days'\");\n      }\n      return new LiteralSchedule(`rate(${duration.formatTokenToNumber()})`);\n    }\n    if (duration.toSeconds() === 0) {\n      throw new Error('Duration cannot be 0');\n    }\n\n    let rate = maybeRate(duration.toDays({ integral: false }), 'day');\n    if (rate === undefined) { rate = maybeRate(duration.toHours({ integral: false }), 'hour'); }\n    if (rate === undefined) { rate = makeRate(duration.toMinutes({ integral: true }), 'minute'); }\n    return new LiteralSchedule(rate);\n  }\n\n  /**\n   * Construct a Schedule from a moment in time\n   */\n  public static at(moment: Date): Schedule {\n    return new LiteralSchedule(`at(${formatISO(moment)})`);\n  }\n\n  /**\n   * Create a schedule from a set of cron fields\n   */\n  public static cron(options: CronOptions): Schedule {\n    if (options.weekDay !== undefined && options.day !== undefined) {\n      throw new Error('Cannot supply both \\'day\\' and \\'weekDay\\', use at most one');\n    }\n\n    const minute = fallback(options.minute, '*');\n    const hour = fallback(options.hour, '*');\n    const month = fallback(options.month, '*');\n    const year = fallback(options.year, '*');\n\n    // Weekday defaults to '?' if not supplied. If it is supplied, day must become '?'\n    const day = fallback(options.day, options.weekDay !== undefined ? '?' : '*');\n    const weekDay = fallback(options.weekDay, '?');\n\n    return new LiteralSchedule(`cron(${minute} ${hour} ${day} ${month} ${weekDay} ${year})`);\n  }\n\n  /**\n   * Retrieve the expression for this schedule\n   */\n  public abstract readonly expressionString: string;\n\n  protected constructor() {\n  }\n}\n\n/**\n * Options to configure a cron expression\n *\n * All fields are strings so you can use complex expressions. Absence of\n * a field implies '*' or '?', whichever one is appropriate.\n *\n * @see https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions\n */\nexport interface CronOptions {\n  /**\n   * The minute to run this rule at\n   *\n   * @default - Every minute\n   */\n  readonly minute?: string;\n\n  /**\n   * The hour to run this rule at\n   *\n   * @default - Every hour\n   */\n  readonly hour?: string;\n\n  /**\n   * The day of the month to run this rule at\n   *\n   * @default - Every day of the month\n   */\n  readonly day?: string;\n\n  /**\n   * The month to run this rule at\n   *\n   * @default - Every month\n   */\n  readonly month?: string;\n\n  /**\n   * The year to run this rule at\n   *\n   * @default - Every year\n   */\n  readonly year?: string;\n\n  /**\n   * The day of the week to run this rule at\n   *\n   * @default - Any day of the week\n   */\n  readonly weekDay?: string;\n}\n\nclass LiteralSchedule extends Schedule {\n  constructor(public readonly expressionString: string) {\n    super();\n  }\n}\n\nfunction fallback<T>(x: T | undefined, def: T): T {\n  return x === undefined ? def : x;\n}\n\nfunction formatISO(date?: Date) {\n  if (!date) { return undefined; }\n\n  return date.getUTCFullYear() +\n    '-' + pad(date.getUTCMonth() + 1) +\n    '-' + pad(date.getUTCDate()) +\n    'T' + pad(date.getUTCHours()) +\n    ':' + pad(date.getUTCMinutes()) +\n    ':' + pad(date.getUTCSeconds());\n\n  function pad(num: number) {\n    if (num < 10) {\n      return '0' + num;\n    }\n    return num;\n  }\n}\n\n/**\n * Return the rate if the rate is whole number\n */\nfunction maybeRate(interval: number, singular: string) {\n  if (interval === 0 || !Number.isInteger(interval)) { return undefined; }\n  return makeRate(interval, singular);\n}\n\n/**\n * Return 'rate(${interval} ${singular}(s))` for the interval\n */\nfunction makeRate(interval: number, singular: string) {\n  return interval === 1 ? `rate(1 ${singular})` : `rate(${interval} ${singular}s)`;\n}\n"],
  "mappings": "+MAKA,cAA8B,CA+D5B,aAAA,QAzDc,YAAW,WAAkB,CACzC,MAAO,IAAI,iBAAgB,kBAMf,MAAK,SAAkB,CACnC,0DAAI,SAAS,eAAgB,CAE3B,GAAI,CAAC,AADqB,CAAC,SAAU,UAAW,OAAQ,QAAS,MAAO,QACjD,SAAS,SAAS,aACvC,KAAM,IAAI,OAAM,2FAElB,MAAO,IAAI,iBAAgB,QAAQ,SAAS,0BAE9C,GAAI,SAAS,cAAgB,EAC3B,KAAM,IAAI,OAAM,wBAGlB,GAAI,MAAO,UAAU,SAAS,OAAO,CAAE,SAAU,KAAU,OAC3D,MAAI,QAAS,QAAa,MAAO,UAAU,SAAS,QAAQ,CAAE,SAAU,KAAU,SAC9E,OAAS,QAAa,MAAO,SAAS,SAAS,UAAU,CAAE,SAAU,KAAS,WAC3E,GAAI,iBAAgB,YAMf,IAAG,OAAY,CAC3B,MAAO,IAAI,iBAAgB,MAAM,UAAU,kBAM/B,MAAK,QAAoB,CACrC,uFAAI,QAAQ,UAAY,QAAa,QAAQ,MAAQ,OACnD,KAAM,IAAI,OAAM,2DAGlB,KAAM,QAAS,SAAS,QAAQ,OAAQ,KAClC,KAAO,SAAS,QAAQ,KAAM,KAC9B,MAAQ,SAAS,QAAQ,MAAO,KAChC,KAAO,SAAS,QAAQ,KAAM,KAG9B,IAAM,SAAS,QAAQ,IAAK,QAAQ,UAAY,OAAY,IAAM,KAClE,QAAU,SAAS,QAAQ,QAAS,KAE1C,MAAO,IAAI,iBAAgB,QAAQ,UAAU,QAAQ,OAAO,SAAS,WAAW,UAvDpF,QAAA,SAAA,qHAuHA,6BAA8B,SAAQ,CACpC,YAA4B,iBAAwB,CAClD,QAD0B,KAAA,iBAAA,kBAK9B,kBAAqB,EAAkB,IAAM,CAC3C,MAAO,KAAM,OAAY,IAAM,EAGjC,mBAAmB,KAAW,CAC5B,GAAI,CAAC,KAAQ,OAEb,MAAO,MAAK,iBACV,IAAM,IAAI,KAAK,cAAgB,GAC/B,IAAM,IAAI,KAAK,cACf,IAAM,IAAI,KAAK,eACf,IAAM,IAAI,KAAK,iBACf,IAAM,IAAI,KAAK,iBAEjB,aAAa,IAAW,CACtB,MAAI,KAAM,GACD,IAAM,IAER,KAOX,mBAAmB,SAAkB,SAAgB,CACnD,GAAI,aAAa,GAAK,CAAC,OAAO,UAAU,WACxC,MAAO,UAAS,SAAU,UAM5B,kBAAkB,SAAkB,SAAgB,CAClD,MAAO,YAAa,EAAI,UAAU,YAAc,QAAQ,YAAY",
  "names": []
}
